[{"title":"React Hooks 模拟 redux","date":"2019-09-04T16:00:00.000Z","path":"react-hooks-redux/","text":"React Hooks 在 react@10.8 中已经发布，刚发布的时候自己也进行了简单的学习，之前也写过一篇学习 hooks 基础用法的文章。学习之后用到的场景并不多，最近再次学习并在项目中应用起来，真正体会到它的强大之处。 本文呢不再是介绍基础的 hooks API 的应用，而是基于hooks如何实现类似 redux 这样的状态管理。 实现思路做 react 项目，一般按照正常的流程写组件就能满足业务场景，随着业务复杂度的增加，数据交互会变的复杂，会逐渐考虑到使用工具或者库来管理数据，常见的就是 redux、mbox、dva 等。 使用 react hooks 的时候，我们发现它提供了很多的 api 供我们操作数据，那么如何才能利用这些 api 实现类似 redux 这样的数据管理呢。 redux 集中管理数据，通过 Provider 组件将数据共享给子组件，然后再通过 connect 将 store 与组件进行连接，这是 redux 最核心的功能。 这里的核心就是实现数据共享，这时我们可以使用 Context 来实现。Context 本意是上下文，它提供一个 Provider 和一个 Consumer，也就是生产者/消费者模式，在某个顶层提供一个 Provider ，下面的子元素通过 Consumer 来消费 Provider 里的数据和方法。 通过这个概念，我们把不同层级里的组件共享同一个顶层 Provider，并且组件内部使用 Consumer 来消费共享数据。 当我们能共享数据后，还剩一个问题就是如何更改 Provider 里的数据呢？答案是：useReducer。 有了这样的思路，我们一步步来实现它。 实现过程1. props传递如果我们有一个场景，两个字组件需要共享父组件的状态，我们通常的做法是在父组件中定义状态，再通过 props 传递给子组件，实现状态共享。 12345678910111213141516171819202122import React from 'react'function Parent() &#123; const colors = ['red', 'blue'] return ( &lt;&gt; &lt;Child1 color=&#123;colors[0]&#125; /&gt; &lt;Child2 color=&#123;colors[1]&#125; /&gt; &lt;/&gt; )&#125;function Child1(props) &#123; return ( &lt;div style=&#123;&#123; background: props.color &#125;&#125;&gt;I am &#123;props.color&#125;&lt;/div&gt; )&#125; function Child2(props) &#123; return ( &lt;div style=&#123;&#123; background: props.color &#125;&#125;&gt;I am &#123;props.color&#125;&lt;/div&gt; )&#125; 这是最简单的实现方式，子组件可以共享到父组件的状态。但是如果子组件层级加深被嵌套在很深的组件层级中，那么这个状态也需要一层层往下传递，这可能也是我们经常遇到的问题，这也是为什么我们会使用 redux 这种状态管理库的原因。 2. 使用Context接下来使用 Context ，通过 createContext 创建需要的 Context ，再在子组件中通过 useContext 拿到共享数据。 12345678910111213141516171819202122232425262728import React from 'react'const Context = React.createContext(null)function Parent() &#123; const initState = &#123; colors: [\"red\", \"blue\"] &#125; return ( &lt;Context.Provider value=&#123;initState&#125;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;/Context.Provider&gt; )&#125;function Child1() &#123; const &#123; colors &#125; = React.useContext(Context) return ( &lt;div style=&#123;&#123; background: colors[0] &#125;&#125;&gt;I am &#123;colors[0]&#125;&lt;/div&gt; )&#125; function Child2() &#123; const &#123; colors &#125; = React.useContext(Context) return ( &lt;div style=&#123;&#123; background: colors[1] &#125;&#125;&gt;I am &#123;colors[1]&#125;&lt;/div&gt; )&#125; 这样我们就摆脱使用 props 传递状态也同样实现共享状态。 3. 更新状态上面已经能拿到数据，进一步实现点击元素修改颜色，这里就需要使用到 useReducer 来模拟触发改变。 12345678function reducer(state, action) &#123; const &#123; type, colors &#125; = action if (type === 'CHANGE_COLOR') &#123; return &#123; colors &#125; &#125; else &#123; throw new Error() &#125;&#125; 定义一个 reducer，是不是很熟悉，和 redux 中的 reducer 几乎一样，这里对 action 做了简化处理。 useReducer 方法会接受一个 reducer 和 state，返回 state 和 dispatch ，我们再把 state 和 dispatch 通过 Provider 共享给子组件使用。 123456789101112function Parent() &#123; const initState = &#123; colors: [\"red\", \"blue\"] &#125; const [state, dispatch] = React.useReducer(reducer, initState) return ( &lt;Context.Provider value=&#123;&#123; colors: state.colors, dispatch&#125;&#125;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;/Context.Provider&gt; )&#125; 子组件中拿到 dispatch 并改变 colors 123456789101112function Child1() &#123; console.log(React.useContext(Context)) // &#123;colors: Array(2), dispatch: ƒ&#125; const &#123; colors, dispatch &#125; = React.useContext(Context) return ( &lt;div style=&#123;&#123; background: colors[0] &#125;&#125; onClick=&#123;() =&gt; &#123; dispatch(&#123; type: \"CHANGE_COLOR\", colors: [\"yellow\", \"blue\"] &#125;) &#125;&#125;&gt;I am &#123;colors[0]&#125;&lt;/div&gt; )&#125; 这样就基本实现了共享状态，基本实现了不使用 redux 实现状态共享。 4. 抽离Provider 和 获取状态的自定义hook假如我们是个小型项目，可能会把这个 Provider 放在顶层，也就是进行全局的状态管理，我们将 Provider 抽离出来。 12345678910111213141516171819202122232425// state.jsimport React, &#123; useContext, useReducer &#125; from 'react'function reducer(state, action) &#123; const &#123; type, colors &#125; = action if (type === 'CHANGE_COLOR') &#123; return &#123; colors &#125; &#125; else &#123; throw new Error() &#125;&#125;const initState = &#123; colors: [\"red\", \"blue\"]&#125;export const AppContext = React.createContext(null)export function AppProvider (&#123; children &#125;) &#123; return ( &lt;AppContext.Provider value=&#123;useReducer(reducer, initState)&#125;&gt; &#123;children&#125; &lt;/AppContext.Provider&gt; )&#125; 最后添加一个自定义hook来获取 AppContext 里的状态和方法。 123import React, &#123; useContext, useReducer &#125; from 'react'export const AppContext = React.createContext(null)export const useAppState = () =&gt; useContext(AppContext) 组件中使用 1234567891011121314151617181920212223import React from 'react'import &#123; AppProvider, useAppState &#125; from './state'function Parent() &#123; return ( &lt;AppProvider&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;/AppProvider&gt; )&#125;function Child1() &#123; const [state, dispatch] = useAppState() return ( &lt;div style=&#123;&#123; background: state.colors[0] &#125;&#125; onClick=&#123;() =&gt; &#123; dispatch(&#123; type: \"CHANGE_COLOR\", colors: [\"yellow\", \"blue\"] &#125;) &#125;&#125;&gt;I am &#123;state.colors[0]&#125;&lt;/div&gt; )&#125; 这样基本就实现了状态的共享。但是和我们常用的 redux 还差了点，熟悉 redux 的都知道稍微复杂点的项目都会按模块拆分，拆分成小的 reducer 和 state 最终再通过 combineReducers 合并 reducer 形成一个全局的 store ，那么如何通过 hooks 来实现 reducer 的拆分和合并呢？ 5. 合并reducer在复杂的业务场景中会按功能模块拆分成多个小的 reducer 最终再进行整合，按照 redux 的思维，我们页可以实现一个 combineReducers 函数来合并它们。 1234567891011121314151617181920212223242526272829export default function combineReducers(reducers) &#123; const reducersKey = Object.keys(reducers) const finalReducers = &#123;&#125; for(let i = 0; i &lt; reducersKey.length; i++) &#123; const key = reducersKey[i] if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) return function combination(state = &#123;&#125;, action) &#123; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; throw new Error() &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; 然后再拆分写 action 和 reducer ，这里稍微有些不同，需要将 reducer 中的 state 导出以便进行整合。 例如： home 模块的 action 和 reducer 1234567891011121314151617181920212223// actions/home.jsexport const CHANGE_COLOR = 'CHANGE_COLOR'export const changeColor = (dispatch, colors) =&gt; &#123; dispatch(&#123; type: \"CHANGE_COLOR\", colors &#125;)&#125;// reducers/home.jsimport &#123; CHANGE_COLOR &#125; from '../actions/home'export const homeState = &#123; colors: [\"red\", \"blue\"]&#125;export const homeReducer = (state = homeState, action) =&gt; &#123; const &#123; type, colors &#125; = action switch (type) &#123; case CHANGE_COLOR: return &#123;colors&#125; default: return state &#125;&#125; user 模块的 action 和 reducer 1234567891011121314151617181920212223242526272829// actions/user.jsexport const CHANGE_USER_NAME = 'CHANGE_USER_NAME'export const changeUserName = async (dispatch, userName) =&gt; &#123; let finalName = await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(userName === 'sqb' ? 'Undo' : 'sqb') &#125;, 1000) &#125;) dispatch(&#123; type: CHANGE_USER_NAME, name: finalName &#125;)&#125;// reducers/user.jsimport &#123; CHANGE_USER_NAME &#125; from '../actions/user'export const userState = &#123; name: 'sqb', age: 27&#125;export const userReducer = (state = userState, action) =&gt; &#123; const &#123; type &#125; = action switch (type) &#123; case CHANGE_USER_NAME: return &#123; ...state, name: action.name &#125; default: return state &#125;&#125; 因为 useReducer 需要传入 reducer 和初始的 state ，那么需要把小的 reducer 中的状态也进行合并。 整合，同时到处合并后的 reducer 和 初始化的 initState 。 123456789101112import combineReducers from './combineReducers'import &#123; homeState, homeReducer &#125; from './home'import &#123; userState, userReducer &#125; from './user'export const reducer = combineReducers(&#123; home: homeReducer, user: userReducer&#125;)export const initState = &#123; home: homeState, user: userState&#125; 6. 构建store使用 createContext 创建 Context 对象得到 Provider ，通过 useContext 得到全局状态和更新状态的方法。 1234567891011import React, &#123; useContext, useReducer &#125; from 'react'import &#123; reducer, initState &#125; from './reducer'export const AppContext = React.createContext(null)export function AppProvider (&#123; children &#125;) &#123; return ( &lt;AppContext.Provider value=&#123;useReducer(reducer, initState)&#125;&gt; &#123;children&#125; &lt;/AppContext.Provider&gt; )&#125; export const useAppState = () =&gt; useContext(AppContext) 子组件中获取 state 和 修改 state 123456789101112131415161718import React from 'react';import &#123; useAppState &#125; from '../store'import &#123; changeColor &#125; from '../store/actions/home'function Child1(props) &#123; const [state, dispatch] = useAppState() const &#123; home: &#123; colors &#125; &#125; = state const onClick = () =&gt; &#123; changeColor(dispatch, [\"yellow\", \"blue\"]) &#125; return ( &lt;div style=&#123;&#123; background: colors[0] &#125;&#125; onClick=&#123;onClick&#125; &gt; I am &#123;colors[0]&#125; truetrue&lt;/div&gt; )&#125;export default Child1; 这样基本上就实现了 redux 的雏形，action 、reducer 、store 也保持了基本一致的风格。 7. 优化我们实现状态共享，在各个组件中打印日志，发现一个问题，该组件不想关的状态更新也会导致组件重新渲染。 原因是 调用了 useContext 的组件总会在 context 值变化时重新渲染。也就是说只要组件中使用了共享状态，那么 context 中的任何状态发生改变都会触发使用共享状态的组件重新渲染，这会导致很多没必要的性能开销。 还好 hooks 提供了 useMemo ，可以利用它来优化性能。 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。 因此改造我们的子组件 1234567891011121314151617181920import &#123; useAppState &#125; from '../store'import &#123; changeColor &#125; from '../store/actions/home'function Child1(props) &#123; const [state, dispatch] = useAppState() const &#123; home: &#123; colors &#125; &#125; = state return React.useMemo(() =&gt; &#123; console.log('Child1 render') const onClick = () =&gt; &#123; changeColor(dispatch, [\"yellow\", \"blue\"]) &#125; return ( &lt;div style=&#123;&#123; background: colors[0] &#125;&#125; onClick=&#123;onClick&#125;&gt; I am &#123;colors[0]&#125; &lt;/div&gt; ) &#125;, [colors, dispatch]);&#125;export default Child1; 这样改造之后只会在组件的依赖项发生改变的时候才会重新渲染。 总结这只是利用 react hooks 简单实现了类似 redux 的数据管理，可以不依赖任何库实现状态管理和共享，当然也可以嵌套，可以拆分，可以按模块拆分状态共享，可以在小项目中进行尝试和运用，它会让我们的编码更加的灵活。","tags":[{"name":"react","slug":"react","permalink":"/tags/react/"},{"name":"react-hooks-redux","slug":"react-hooks-redux","permalink":"/tags/react-hooks-redux/"}]},{"title":"URL解析","date":"2019-07-01T16:00:00.000Z","path":"URL_Analysis/","text":"今天上班前的几分钟在掘金上看到一篇文章在讲“有趣的JS特性”,文中讲到利用JS特性解析url,于是乎学习一下做下记录。 我们为什么需要解析url呢,一版来说,我们需要从url中提取某些重要信息,比如从url中提取host、origin、pathname、protocol、search等信息。 1. window.location针对获取当前页面url地址的情况，使用window.location或许是最简单直接的方式了。 12345678910111213141516console.log(window.location);// Location &#123;replace: ƒ, href: \"https://juejin.im/post/5d1716e4f265da1bbc6fea1e?utm_source=gold_browser_extension\", ancestorOrigins: DOMStringList, origin: \"https://juejin.im\", protocol: \"https:\", …&#125;// ancestorOrigins: DOMStringList &#123;length: 0&#125;// assign: ƒ assign()// hash: \"\"// host: \"juejin.im\"// hostname: \"juejin.im\"// href: \"https://juejin.im/post/5d1716e4f265da1bbc6fea1e?utm_source=gold_browser_extension\"// origin: \"https://juejin.im\"// pathname: \"/post/5d1716e4f265da1bbc6fea1e\"// port: \"\"// protocol: \"https:\"// reload: ƒ reload()// replace: ƒ ()// search: \"?utm_source=gold_browser_extension\"// toString: ƒ toString() 我们基本可以获取到我们常用的所有信息，只是查询字符串需要我们手动解析。 2. 利用a标签解析 url这种方案是我今天在掘金上看到的，这个方案是利用了a标签的特性，给href属性赋值url，就可以解析url获得我们想要的信息字段。 相比于第一种方式，这种可以解析任意的url地址。 1234567891011function parseURL(url) &#123; var a = document.createElement('a'); a.href = url; console.log(a); return &#123; host: a.hostname, port: a.port, query: a.search, hash: a.hash.replace('#','') &#125;;&#125; 打印创建出来的a标签，可以看到a作为dom元素的所有属性，以及url解析后的字段，字段包含 window.location 解析出来的字段。 但是如果需要解析查询字符串，还是需要手动解析。 3. new URL()还新学习到一种解析 url 的方法。 URL() 构造函数返回一个新创建的 URL 对象，表示由一组参数定义的 URL。 1let url = new URL(url, [base]) url: 是一个表示绝对或相对 URL 的 DOMString。如果url 是相对 URL，则会将 base 用作基准 URL。如果 url 是绝对URL，则将忽略 base，无论是否有给出。base: 可选，是一个表示基准 URL 的 DOMString，在 url 是相对 URL 时，它才会起效。如果未指定，则默认为’’。 1234567891011121314let url = new URL('https://juejin.im/post/5d1716e4f265da1bbc6fea1e?utm_source=gold_browser_extension');console.log(url);// hash: \"\"// host: \"juejin.im\"// hostname: \"juejin.im\"// href: \"https://juejin.im/post/5d1716e4f265da1bbc6fea1e?utm_source=gold_browser_extension\"// origin: \"https://juejin.im\"// password: \"\"// pathname: \"/post/5d1716e4f265da1bbc6fea1e\"// port: \"\"// protocol: \"https:\"// search: \"?utm_source=gold_browser_extension\"// searchParams: URLSearchParams &#123;&#125;// username: \"\" 可以看到也能正常解析url，但注意观察，生成的 url 对象中多了一个 searchParams 属性，它的值是 URLSearchParams，它是干什么的呢？ 翻看 MDN ，它是这样描述的 URLSearchParams 接口定义了一些实用的方法来处理 URL 的查询字符串。 没错就是用来操作url的查询字符串的，它拥有很强大的功能，可以对查询字符串进行查询、获取、设置、排序等操作。 12345678910111213console.log(URLSearchParams.prototype);// append: ƒ append()// delete: ƒ delete()// entries: ƒ entries()// forEach: ƒ forEach()// get: ƒ ()// getAll: ƒ getAll()// has: ƒ has()// keys: ƒ keys()// set: ƒ ()// sort: ƒ sort()// toString: ƒ toString()// values: ƒ values() 具体API的使用查看文档既可，这为从url中获取查询字符串中的信息带来了极大的方便。 另外，在使用 new URL() 的时候有几点需要注意，先看下面几个例子。 12345678910111213var a = new URL(\"/\", \"https://developer.mozilla.org\"); // Creates a URL pointing to 'https://developer.mozilla.org/'var b = new URL(\"https://developer.mozilla.org\"); // Creates a URL pointing to 'https://developer.mozilla.org/'var c = new URL('en-US/docs', b); // Creates a URL pointing to 'https://developer.mozilla.org/en-US/docs'var d = new URL('/en-US/docs', b); // Creates a URL pointing to 'https://developer.mozilla.org/en-US/docs'var f = new URL('/en-US/docs', d); // Creates a URL pointing to 'https://developer.mozilla.org/en-US/docs'var g = new URL('/en-US/docs', \"https://developer.mozilla.org/fr-FR/toto\"); // Creates a URL pointing to 'https://developer.mozilla.org/en-US/docs'var h = new URL('/en-US/docs', a); // Creates a URL pointing to 'https://developer.mozilla.org/en-US/docs'var i = new URL('/en-US/docs', ''); // Raises a TypeError exception as '' is not a valid URLvar j = new URL('/en-US/docs'); // Raises a TypeError exception as '/en-US/docs' is not a valid URLvar k = new URL('http://www.example.com', 'https://developers.mozilla.com'); // Creates a URL pointing to 'http://www.example.com/'var l = new URL('http://www.example.com', b); // Creates a URL pointing to 'http://www.example.com/' 不难发现以下规律： 最终生成的 url = url || base 的 origin + url url 和 base 都缺少 origin、host 等信息的时候会报错 url具备完整url信息的时候base会失效 关于查询字符串的解析，实现的方式很多，这里不多说了。 另外再补充一下使用 URL 的静态方法来实现文件下载的方案。 URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。在每次调用 createObjectURL() 方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，应该在安全的时机主动释放掉它们。 使用 a 标签 配合 URL 对象实现下载保存。 123456789101112axios(&#123; method: \"get\", url: `/download/$&#123;id&#125;`, responseType: \"blob\",&#125;).then(response =&gt; &#123; var a = document.createElement(\"a\"); var url = window.URL.createObjectURL(response.data); a.href = url; a.download = 'filename'; a.click(); window.URL.revokeObjectURL(url);&#125;);","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"}]},{"title":"CSS - 媒体查询@media","date":"2019-03-30T16:00:00.000Z","path":"css_media/","text":"记录一次小需求引发的对媒体查询的学习。 最近接到一个小需求，只做页面重构，本着切图的想法就准备开工了，打开设计给出的设计稿，发现里面有1366px 和 1920px 宽度的两份设计稿和切图，第一想法是按照某一个尺寸来做，经过跟产品和设计确认，是要求适配这两个尺寸。由于之前做这种适配性的页面经验较少，所以刚开始是有点懵的，有点不知所措。 经过分析，其实就是两种尺寸下，各个元素的大小、字体、间距等的尺寸不同，那么想到的就是在不同的屏幕尺寸下用不同的布局尺寸，自然就想到了媒体查询。 解决方案根据媒体查询，获得浏览器的宽度，根据宽度加载对应的css，具体的实现方式有下面几种：1.直接在CSS中使用1234567@media screen and (max-width: 1919px) &#123; true// CSS样式&#125; @media screen and (min-width: 1920px) &#123; true// CSS样式&#125; 2.在@import中引入123456&lt;style type=\"text/css\" media=\"screen and (max-width:1919px)\"&gt; @import url(\"../css/index1366.css\");&lt;/style&gt;&lt;style type=\"text/css\" media=\"screen and (max-width:1920px)\"&gt; @import url(\"../css/index1920.css\");&lt;/style&gt; 3.在head中动态引入12&lt;link media=\"screen and (max-width: 1919px)\" rel=\"stylesheet\" href=\"../css/index1366.css\"&gt;&lt;link media=\"screen and (min-width: 1920px)\" rel=\"stylesheet\" href=\"../css/index1920.css\"&gt; 在最终选择是第三种方案，这种方案更适合本次的需求，把相同的代码写在公用的文件中，差异的css代码，分别写在对应的css文件中，这样方便管理和修改。第二种方式和第三种其实是一样的但是多用一个 style 标签，第一种是将代码合在一起虽然只管，但是显得比较混乱，不方便分离和管理。 媒体查询学习媒体查询，添加自CSS3，允许内容的呈现针对一个特定范围的输出设备而进行裁剪，而不必改变内容本身。媒体查询包含一个可选的媒体类型和媒体特性表达式(0或多个)最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示文档所使用的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。 当媒体查询未true时，对应的样式就会进行应用。使用 &lt;link&gt; 标签指向的样式表，即使媒体查询为false也会下载但是不会被应用。1@media 媒体类型 逻辑操作符 媒体特征 媒体类型让我们先了解一下媒体类型，这个大家会比较熟悉一点，我们通常会用到的类型会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。其实，media type有很多种： 类型 解释 all 所有设备 braille 盲文 embossed 盲文打印 handheld 手持设备 print 文档打印或打印预览模式 projection 项目演示，比如幻灯 screen 彩色电脑屏幕 speech 演讲 tty 固定字母间距的网格的媒体，比如电传打字机 tv 电视 逻辑操作符逻辑操作符包括not、and和only等，构建复杂的媒体查询。and操作符用来把多个媒体属性组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。not操作符用来对一条媒体查询的结果进行取反。only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。若使用了not或only操作符，必须明确指定一个媒体类型。 andand关键字用于合并多个媒体属性或合并媒体属性与媒体类型。1@media screen and (min-width: 700px) and (max-width: 1919px) &#123; ... &#125; 表示在电脑屏幕跨宽度在700-1910之间的时候应用的css样式。 notnot 关键字应用于整个媒体查询，在媒体查询为假时返回真 (比如 monochrome 应用于彩色显示设备上或一个600像素的屏幕应用于 min-width: 700px 属性查询上 )。在逗号媒体查询列表中not仅会否定它应用到的媒体查询上而不影响其它的媒体查询。 not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询。1@media not all and (monochrome) &#123; ... &#125; 等价于：1@media not (all and (monochrome)) &#123; ... &#125; 而不是1@media (not all) and (monochrome) &#123; ... &#125; onlyonly关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式：1&lt;link rel=\"stylesheet\" media=\"only screen and (color)\" href=\"example.css\" /&gt; 逗号分隔列表媒体查询中使用逗号分隔效果等同于or逻辑操作符。当使用逗号分隔的媒体查询时，如果任何一个媒体查询返回真，样式就是有效的。逗号分隔的列表中每个查询都是独立的，一个查询中的操作符并不影响其它的媒体查询。这意味着逗号媒体查询列表能够作用于不同的媒体属性、类型和状态。1@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125; 表示在最小宽度为700像素或是横屏的手持设备上应用一组样式。 媒体特征大多数媒体属性可以带有“min-”或“max-”前缀，用于表达“最低…”或者“最高…”。例如，max-width:12450px表示应用其所包含样式的条件最高是宽度为12450px，大于12450px则不满足条件，不会应用此样式。这避免了使用与HTML和XML冲突的“&lt;”和“&gt;”字符。如果你未向媒体属性指定一个值，并且该特性的实际值不为零，则该表达式被解析为真。常用的媒体特征有： 属性 值 Min/Max 描述 color 整数 yes 每种色彩的字节数 color-index 整数 yes 色彩表中的色彩数 device-aspect-ratio 整数/整数 yes 宽高比例 device-height length yes 设备屏幕的输出高度 device-width length yes 设备屏幕的输出宽度 grid 整数 no 是否是基于格栅的设备 height length yes 渲染界面的高度 monochrome 整数 yes 单色帧缓冲器中每像素字节 resolution 分辨率(“dpi/dpcm”) yes 分辨率 scan Progressive interlaced no tv媒体类型的扫描方式 width length yes 渲染界面的宽度 orientation Portrait/landscape no 横屏或竖屏 max与min height min-height max-height device-width min-device-width max-device-width device-height min-device-height max-device-height aspect-ratio min-aspect-ratio max-aspect-ratio device-aspect-ratio min-device-aspect-ratio max-device-aspect-ratio color min-color max-color color-index min-color-index max-color-index Monochrome min-monochrome max-monochrome Resolution min-resolution max-resolution 媒体查询浏览器支持度： IE 9以下不支持 Firefox 3.5+(Gecko 1.9.1+)支持 Opera 9.5+完全支持 Opera mini 5支持 webkit 支持大部分属性(safari 3.0的内核版本是522，iPhone 1代的safari的内核版本是524，webkit大概从这个时候开始支持media query，但是对部分属性比如projection支持不好) iPhone OS 3.2之前的版本不支持orientation属性，iPad和iPhone 4支持该属性。 iPhone Safari不支持orientation(iPhone 4支持) 总结CSS3的media query是一个很强大也很好用的工具，它为我们在不同的设备和环境下实现丰富的界面提供了一种快捷方法，虽然现在各个浏览器对它的支持还有些差异，但是大家都在改进，IE 9已经开始支持media query了。不过目前media query的最大舞台是在高端手持设备，相信随着移动互联网的快速发展，media query也会很好发挥自己的作用。 相关链接：【CSS媒体查询】【@media】","tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"媒体查询","slug":"媒体查询","permalink":"/tags/媒体查询/"},{"name":"media","slug":"media","permalink":"/tags/media/"}]},{"title":"CSS - 实现优惠券","date":"2018-12-19T16:00:00.000Z","path":"css_coupon/","text":"最近在项目开发中遇到一个优惠券需求，与常见的优惠券类似，中部有反向的圆角。 类似于这样的优惠券，在开发中如何去实现呢。 1. 使用背景图我们遇到这样的需求，第一反应可能是使用背景图，要一张白底的带内圆角的背景图，就像下面这样： 这样当然没有问题，简单，方便，没有兼容性问题，即使在低版本的IE中也没有丝毫的问题，但是如果不考虑低版本浏览器，不考虑兼容性的话，使用css来实现会更好。 使用css易于控制，如设计有改尺寸，我们只需要更改部分代码就能实现 不使用图片，减少网络请求，css实现加载起来更快 2. 使用css，内圆角背景与底色一样如果优惠券的底色是个纯色的，那么其实可以考虑这种很简便的实现方式，即使用两个圆角，背景色与底色相同即可。 123&lt;div class=\"wrapper1\"&gt; &lt;div class=\"coupon\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435.wrapper1 &#123; width: 750px; height: 250px; display: flex; justify-content: center; align-items: center; background: #EA364B;&#125;.wrapper1 .coupon &#123; width: 710px; height: 220px; overflow: hidden; background: #ffffff; border-radius: 8px; position: relative;&#125;.wrapper1 .coupon::before, .wrapper1 .coupon::after &#123; content: ''; position: absolute; width: 30px; height: 30px; border-radius: 50%; background: #EA364B;&#125;.wrapper1 .coupon::before &#123; top: -15px; left: 520px;&#125;.wrapper1 .coupon::after &#123; bottom: -15px; left: 520px;&#125; 这样就能实现以上的效果，但是这样有一个弊端，伪元素before和after，的背景色必须与外层容器的背景色保持一致，而当外层背景色改变或者是渐变的那就会出现无法避免的问题，伪元素的背景色不能与外层背景色很好的衔接。 所以最理想的状态是内圆角的背景色是透明的即可避免。 这种方式由于本身背景色是白色，即使伪元素的背景使用 transparent 也会展示成白色，并不能穿透这层白色的背景。 3. 使用css，背景剪切clip为了实现上面的透明圆角，将优惠券从向内的圆角的中心处分为左右两部分。为了效果明显右半部分先用黑色。 12345678910111213141516171819202122232425&lt;div class=\"coupon\"&gt; &lt;div class=\"coupon-left\"&gt;&lt;/div&gt; &lt;div class=\"coupon-right\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .coupon &#123; width: 710px; height: 220px; border-radius: 8px; overflow: hidden; display: flex; justify-content: center; align-items: center; &#125; .coupon-left &#123; width: 520px; height: 220px; background: #ffffff; &#125; .coupon-right &#123; width: 190px; height: 220px; background: #252525; &#125;&lt;/style&gt; 下面就来实现中间看着比较复杂的”凹槽”部分 我能想到跟圆角相关的有圆角、圆形、径向…这些吧 有人说svg也可以，确实svg什么都可以做，不光是这种形状，只要画个路径，填充一下就完事，这个比较通用，并不是这个特例，所以在这里不讨论用这个方式。还有一个原因，svg生成的形状也是固定了的，只能等比缩放，不能做其他自适应了。 实现圆角可以先实现一个圆形，背景色默认透明，设置边框，即可得到一个圆形。 加入将圆的边框设的很大，外层容器超出隐藏就可以得到我们想要的效果。 有了以上的思路我们就可以实现我们的需求了，先实现左边，修改css， 去掉原来的背景色，用边框来实现。 1234567891011121314151617.coupon-left &#123; width: 520px; height: 220px; position: relative; /* background: #fff; */ overflow: hidden;&#125;.coupon-left::before &#123; content: ''; position: absolute; right: -575px; top: -575px; width: 30px; height: 30px; border-radius: 50%; border: 560px solid #fff;&#125; 这样就实现了一个右上角的内圆弧，继续按照这个思路实现after元素，定位到右下角，这时候我们发现出现了问题，before元素覆盖了整个的盒子，把右下角的圆角给挡住了。 这里我们可以使用clip属性来裁剪背景，只需要before占据盒子的上半部分，after占据盒子的下班部分。 关于clip这里简单介绍一下，我们一般会用到rect这个功能，有四个值，分别是上右下左。 1clip: rect(&lt;top&gt;, &lt;right&gt;, &lt;bottom&gt;, &lt;left&gt;); 因此，我们使用clip来裁剪一下before，修改代码 1234.coupon-left::before &#123; top: -575px; clip: rect(575px,575px,685px,55px);&#125; 再按照这种思路实现下半部分，调整一下after元素的top值和裁剪的起始值即可。 1234567891011.coupon-left::after &#123; content: ''; position: absolute; right: -575px; width: 30px; height: 30px; border-radius: 50%; border: 560px solid #fff; top: -355px; clip: rect(465px,575px,575px,55px);&#125; 最终效果如下： 同样按照这样的思路可以实现右边部分。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;div class=\"coupon\"&gt; &lt;div class=\"coupon-left\"&gt;&lt;/div&gt; &lt;div class=\"coupon-right\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .coupon &#123; width: 710px; height: 220px; border-radius: 8px; overflow: hidden; display: flex; justify-content: center; align-items: center; &#125; .coupon-left &#123; width: 520px; height: 220px; position: relative; overflow: hidden; /* background: #fff; */ &#125; .coupon-left::before, .coupon-left::after&#123; content: ''; position: absolute; right: -575px; width: 30px; height: 30px; border-radius: 50%; border: 560px solid #fff; &#125; .coupon-left::before &#123; top: -575px; clip: rect(575px,575px,685px,55px); &#125; .coupon-left::after &#123; top: -355px; clip: rect(465px,575px,575px,55px); &#125; .coupon-right &#123; width: 190px; height: 220px; position: relative; overflow: hidden; /* background: #252525; */ &#125; .coupon-right::before, .coupon-right::after &#123; content: ''; position: absolute; right: -105px; width: 30px; height: 30px; border-radius: 50%; border: 280px solid #252525; &#125; .coupon-right::before &#123; top: -295px; clip: rect(295px,485px,405px,295px); &#125; .coupon-right::after &#123; top: -75px; clip: rect(185px,485px,295px,295px); &#125; &lt;/style&gt; 最终效果 还有一个分割线，可以用绝对定位来实现。以上就是整个优惠券背景的实现。 最终效果如下: 4. 相关知识点补充clip 属性支持度，在Can I use 上查看结果如下 在不考虑IE的情况下，使用它是没有太大问题的，移动端可以放心使用。 border-radius 是左上、右上、左下、右下四个方向的复合属性，有两种设值方式 length 定义圆形半径或椭圆的半长轴，半短轴。负值无效。 percentage 使用百分数定义圆形半径或椭圆的半长轴，半短轴。水平半轴相对于盒模型的宽度；垂直半轴相对于盒模型的高度。负值无效。 clip The clip CSS property defines what portion of an element is visible. The clip property applies only to absolutely positioned elements, that is elements with position:absolute or position:fixed. The &lt;top&gt;, &lt;right&gt;, &lt;bottom&gt;, and &lt;left&gt; values may be either a length or auto. If any side’s value is auto, the element is clipped to that side’s inside border edge.","tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"优惠券","slug":"优惠券","permalink":"/tags/优惠券/"},{"name":"CSS-clip","slug":"CSS-clip","permalink":"/tags/CSS-clip/"}]},{"title":"使用webp图片提升前端性能","date":"2018-11-21T16:00:00.000Z","path":"performance_webp/","text":"现在我们看到的大多数网站，80%以上都是图片为主，所以图片的优化是前端性能优化的重要手段，也是非常有必要的一种手段。 我们知道图片的体积越小加载越快，那么图片的优化主要是减小体积或者叫压缩体积，但是压缩体积会造成一定的质量牺牲，那么体积和质量之间怎么均衡呢。 在进行具体的方案之前先了解一下几种常见格式的图片特征： JPEG/JPG优点：JPG 最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉。 缺点：在处理矢量图形或logo等线条感较强、颜色对比强烈的图像时，人为压缩导致图片模糊相当明显。此外jpeg不支持透明，使用很受局限。 适用场景： JPG 适用于呈现色彩丰富的图片，开发中，JPG 图片经常作为大的背景图、轮播图。 PNG-8 与 PNG-24优点：PNG是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数，代表了支持的颜色的种类，24位呈现的色彩更丰富。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。 缺点： 唯一的 缺点 就是体积太大 使用场景：logo、小图标、颜色简单、对比度较强的透明小图在 PNG 格式下有着良好的表现。 SVG优点：文本文件、体积小、不失真、兼容性好，SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强 特性：它和之前提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。作为矢量图，它最显著的优势还是在于图片可无限放大而不失真这一点上。SVG 是文本文件。我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。这使得 SVG 文件可以被非常多的工具读取和修改，具有较强的灵活性。 缺点：一方面是它的渲染成本比较高，这点对性能来说是很不利的。另一方面，SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。 Base64Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。 雪碧图、CSS 精灵、CSS Sprites、图像精灵，说的都是这个东西——一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分的技术，大家都非常熟悉了。 雪碧图的出现是为了从另一个方面进行性能的提升，减少网页图片对服务器的请求次数。 Base64同样也是为了减少请求次数，降低http的开销。 Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。 但是打开一些主流网站我们发现Base64码出现的次数很少，这是因为Base64 编码后，编码的大小会膨胀为原图片的 4/3（这是由 Base64 的编码原理决定的）。如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。 因此，通常我们在开发的时候一般只会将体积非常小的图片进行Base64编码，这个时候Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。 在webpack盛行的情况下，只需要在url-loader中稍加配置就可以将一定体积之下的图片编译成Base64码。也有很多线上的编码工具可供使用。 WebPWebP 于 2010 年被提出， 是 Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。它集多种图片文件格式的优点于一身。 与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类 JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。 这也许是目前图片优化的最佳方式了。 可是万恶的兼容性让他的使用受到了局限。 此外，WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。 webp的应用场景：限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题，即我们上文谈到的兼容性问题。当我们选择适用webp图片，就要考虑在不支持它的浏览器下如何正常显示。 webp图片方案已经被多数大厂应用到项目中，比如在Chrome中打开京东首页，我们查看网络发现他们也使用了很多的webp格式的图片。 再来查看元素，我们发现html是这样的 1&lt;img src=\"//img13.360buyimg.com/mobilecms/s140x140_jfs/t1/4688/27/2880/248823/5b978fe4Eeea92074/5c1ee7f70e8855e9.jpg!q90.webp\" class=\"lazyimg_img\"&gt; 而在IE浏览器中打开，它的html却是这样的 1&lt;img class=\"lazyimg_img\" src=\"//img13.360buyimg.com/mobilecms/s140x140_jfs/t1/4688/27/2880/248823/5b978fe4Eeea92074/5c1ee7f70e8855e9.jpg!q90\"&gt; 我们发现支持webp的浏览器中图片的url地址多了 .webp后缀，而.webp 前面，还跟了一个 .jpg 后缀！ 可以大胆地猜测，这个图片应该至少存在 jpg 和 webp 两种格式，程序会根据浏览器的型号、以及该型号是否支持 WebP 这些信息来决定当前浏览器显示的是 .webp 后缀还是 .jpg 后缀。 那基于这种猜测我们怎么实现呢？ 根据webp支持度决定请求那种格式的图片首先要检测浏览器是否支持webp，下面是网上比较通用的方式。 1234567891011121314151617181920212223;(function(doc) &#123; // 给html根节点加上webps类名 function addRootTag() &#123; doc.documentElement.className += \"webps\"; &#125; // 判断是否有webps=A这个cookie if (!/(^|;\\s?)webps=A/.test(document.cookie)) &#123; var image = new Image(); // 图片加载完成时候的操作 image.onload = function() &#123; // 图片加载成功且宽度为1，那么就代表支持webp了，因为这张base64图是webp格式。如果不支持会触发image.error方法 if (image.width == 1) &#123; // html根节点添加class，并且埋入cookie addRootTag(); document.cookie = \"webps=A; max-age=31536000; domain=58.com\"; &#125; &#125;; // 一张支持alpha透明度的webp的图片，使用base64编码 image.src = 'data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=='; &#125; else &#123; addRootTag(); &#125;&#125;(document)); 把这段js代码在引入css之前加载进来，如果浏览器支持webp则会给html元素添加webps这个类名。 接下来在css中如何使用呢，上面在在html元素加了webps这个类，那么在这个类下的元素就可以使用webp格式图片了 。 比如 12345678.webp-bg &#123; width: 620px; height: 304px; background-image: url(assets/img/iweb.png);&#125;.webps .webp-bg &#123; background-image: url(assets/img/iweb.png.webp);&#125; 如果使用了less或sass则更加简单，效率更高 12345678910111213// less.mixin(@url) &#123; background-image: url(@url); .webps &amp; &#123; background-image: url('@&#123;url&#125;.webp'); &#125;&#125;.webp-bg &#123; width: 620px; height: 304px; .mixin('../../asset/img/iweb.png')&#125; 定义一个函数，函数中处理图片格式的兼容，在背景图片使用的地方使用函数即可 sass中实现同理 123456@mixin bg($url) &#123; background-image: url($url); @at-root(with: all) .webps &amp; &#123; background-image: url($url + '.webp'); &#125;&#125; 那么img标签的url需要检测 document.documentElement.className 中是否包含 webps来决定是否在url后面追加 .webp 这种方式在调试的时候就需要准备好webp图片，那么怎么得到webp图片呢 ？ webp图片可以去网站平台或者格式转换工具生成，但是每次都手动去转换显然是很繁琐效率低下的事情，在node中我们可以使用文件系统检测文件的变化，从而根据变化动态生成webp图片。 实现上述功能需要用到 chokidar 和 webp-converter chokidar 可以用于监控文件、文件夹变化，我们可以传入 glob 文件匹配模式，并可以简单实现递归目录监控。chokidar 可以监控各种文件、文件夹变化事件，包含 add , change , unlink , addDir , unlinkDir 等。 webp-converter 是个webp转换器，用来将图片转换成webp格式，或者由webp转换成其他格式。 上述功能简单实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const chokidar = require('chokidar')const fs = require('fs')const webp = require('webp-converter')const imgDir = 'img'const ignoreFiles = /(^\\..+)/ // 忽略文件.开头const Watcher = chokidar.watch(imgDir, &#123; ignored: path =&gt; ignoreFiles.test(path), persistent: true&#125;) Watcher.on('all', (event, path) =&gt; &#123; // console.log('event:', event, 'path:', path) switch (event) &#123; // add change unlink case 'add': case 'change': createWebp(path) break case 'unlink': deleteImage(path) default: return &#125;&#125;)const deleteImage = path =&gt; &#123; let imgPath = '' if(/\\.webp$/.test(path)) &#123; imgPath = path.substr(0, path.lastIndexOf('.')) &#125; else &#123; imgPath = path + '.webp' &#125; if (fs.existsSync(imgPath)) &#123; fs.unlinkSync(imgPath) &#125;&#125;const createWebp = path =&gt; &#123; if(/\\.webp$/.test(path)) return if(fs.existsSync(path + '.webp')) return webp.cwebp(path, path + '.webp', '-q 75', (status) =&gt; &#123; console.log(status) &#125;)&#125; 这种方式需要在node环境中运行这个js文件，来检测文件夹变化，可以是一个文件夹，也可以检测多个文件夹的变化，后续可以考虑做成webpack插件，以便在工程化项目中更方便的使用。 这样我们就可以在开发调试的时候就使用上webp图片，这种方式更容易控制，但是管理起来更加繁琐。 下面介绍一种结合 Service Workers 的一种实现方案。 Service Workers 动态响应webp图片Service Workers 同样也是比较新的技术，兼容性也不是很好，但是这个也是提升前端性能的重要途径，充分体现优雅降级，在支持它的浏览器中性能表现更为优异，不兼容的继续采用之前的方式。 这种方式的的操作比较简单，在项目中的入口html文件中加入以下代码，用于注册Service Worker。 12345678910// Register the service workerif ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('./service-worker.js').then(function(registration) &#123; // Registration was successful console.log('ServiceWorker registration successful with scope: ', registration.scope); &#125;).catch(function(err) &#123; // registration failed :( console.log('ServiceWorker registration failed: ', err); &#125;);&#125; 如果浏览器支持Service Workers 以上代码就会执行，不支持也不会影响项目的正常运行，用户其实是无感知的. 然后创建Service Worker文件service-worker.js，用于拦截正在传递到服务器的请求。 12345678910111213141516171819// service-worker.js\"use strict\";self.addEventListener('fetch', function (event) &#123; if (/\\.jpe?g$|\\.png$/.test(event.request.url)) &#123; var supportsWebp = false; if (event.request.headers.has('accept')) &#123; supportsWebp = event.request.headers.get('accept').includes('webp'); &#125; if (supportsWebp) &#123; var req = event.request.clone(); var returnUrl = req.url + '.webp' event.respondWith( fetch(returnUrl, &#123; mode: 'no-cors' &#125;) ); &#125; &#125;&#125;); Service Worker 服务注册成功之后，给他添加事件监听，监听所有的fetch事件，fetch事件会拦截所有的请求，当请求发生时，先判断请求是否是请求的JPEG/JPG/PNG格式的图片，然后再通过查看请求头中的accept字段，检测是否支持webp格式的图片，支持的话Accept中存在image/webp Mime类型，如果支持则替换成webp图片的url，去请求webp图片，不支持则正常请求 JPEG/JPG/PNG 格式的图片。 然后来看一下实际的效果， html中是去加载这张png格式的图片，然而我们看看实际的网络请求状况： 这就是 Service Worker 的功劳，我们代码中只是需要 png格式图片，Service Worker 却给我们返回了 webp 格式的图片，再回顾一下 webp 格式图片的特点，相同质量下的图片 webp 比 png 小 26%，如果页面中有大量图片的话，带来的性能优化和节省的网络流量还是相当可观的。 Service Worker 的功能很强大，不仅可以拦截网络请求，还能进行缓存等更强大的功能，所以合理的运用它会给我们的web性能带来更为显著的提升。 Service Worker 只有在https协议下才能注册成功，因此这种方式仅仅只需要解决线上环境的优化处理，在项目开发阶段无需关心，也就是说我们在开发阶段可以不用考虑webp图片的兼容问题，代码中所有图片都使用常用格式图片。 那么现在又有一个问题，这些webp格式的图片怎么出现在线上服务器呢？ 有一些线上工具可以进行图片格式的转换，可以寻找到一些解决方案，也可以使用一些插件工具比如谷歌官方的webp生成工具，安装通过命令生成图片，然后将webp格式图片和常用格式图片一并上传至服务器。 现在webpack已经成为前端开发者项目工程化比不可少的工具了，其实在webpack中配置响应的规则就可以自动化的生成webp的图片，同时配合 url-loader 将一些很小的图片转成 base64 进一步减少图片带来的网络请求。 说webpack 配置之前先说一个 loader – multi-loader，它的主要作用简单来说就是同一规则进行了同时用多个loader进行加载编译，同时输出对应的文件或结果。 那么在 webpack 项目中我们可以只需要将png、jpg、jpeg等常见格式的图片引入项目中，所有的图片地址正常操作，在打包编译的时候，编译输出两张不同格式的图片即可，一张 webp 的，一张常规格式的。 12345678910111213141516const multi = require('multi-loader');...// 图片加载规则true&#123; test: /\\.(jpg|png|gif|jpeg)$/, use: [ &#123; loader: multi( 'url-loader?limit=8192&amp;name=assets/img/[name].[ext].webp!webp-loader?&#123;quality: 75&#125;', 'url-loader?limit=8192&amp;name=assets/img/[name].[ext]' ) &#125; ], &#125;,... 稍作解释，用 url-loader 加载图片，对于小于8kb（大小根据项目而定）的图片进行base64编码；对于大于8kb的图片，编译出正常常规的图片，同时再使用 webp-loader 编译出一张 webp 格式的图片， webp-loader 可以传参数 quality 代码图片的转码的质量，相当于进一步压缩，压缩出来的图片webp 的大小不到原始图片的一半。 然后配合上面的 service worker工作量很小，但是带来的性能优化却是很可观的。 上面这种方式确实可以实现从服务器动态加载webp格式的图片，但是我们发现这样去使用的话仅仅只是需要对项目中的静态图片进行拦截，而相关业务的图片加载并不需要拦截，或许服务器上根本就没有配置webp格式的图片，比如接口中返回的图片地址。因此需要对代码稍作调整，对项目开发中的静态图片地址加参数，在 service worker 中匹配图片格式和参数，从而避免一些不必要的拦截。 1234567891011121314151617181920// service-worker.js\"use strict\";self.addEventListener('fetch', function (event) &#123; if (/(\\.jpe?g|\\.png)\\?iswebp$/.test(event.request.url)) &#123; var supportsWebp = false; if (event.request.headers.has('accept')) &#123; supportsWebp = event.request.headers.get('accept').includes('webp'); &#125; if (supportsWebp) &#123; var req = event.request.clone(); var returnUrl = req.url.substr(0, req.url.lastIndexOf(\"?\")) + \".webp\"; // var returnUrl = req.url + '.webp' event.respondWith( fetch(returnUrl, &#123; mode: 'no-cors' &#125;) ); &#125; &#125;&#125;); webpack 配置中也做一下调整，是打包出来的图片路径拼接上参数。 123456789101112131415const multi = require('multi-loader');...true&#123; test: /\\.(jpg|png|gif|jpeg)$/, use: [ &#123; loader: multi( 'url-loader?limit=8192&amp;name=assets/img/[name].[ext].webp!webp-loader?&#123;quality: 75&#125;', 'url-loader?limit=8192&amp;name=assets/img/[name].[ext]?iswebp' ) &#125; ], &#125;,... 这样就可以只对图片 url 中以 .iswebp结尾的请求进行拦截请求webp格式的图片，如果浏览器不支持，就会正常请求相应格式的图片。 这样做有个好处，除了静态资源上的图片可以这样处理以外，其他动态的接口图片地址根据实际情况也可以实现使用 webp ，因为仅仅只需要在图片url上加上iswebp标识，服务器有对应的webp图片即可。 这种方案更简单适用性更强，结合 Service Worker 性能上的提升会非常明显。 更多关于 Service Worker 的文档请移步 https://lavas.baidu.com/ 结语：webp 格式图片现在呗越来越多的浏览器支持，它小体积高质量的特点使得它越来越受欢迎，我们可以在我们的项目中多使用它，利用它提升前端性能，同时也节省网络流量，webp只是解决方案之一，有更多更好的方案值得我们继续探索。webp 好用但也不是处处可用，项目中根据实际的业务场景和图片特性选择合理的图片格式才能真正体现它们的价值。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"/tags/性能优化/"},{"name":"webp","slug":"webp","permalink":"/tags/webp/"}]},{"title":"React Hooks","date":"2018-11-20T16:00:00.000Z","path":"react-hooks/","text":"React v16.7.0-alpha 版本中发布了新的提案hook，什么是hook？ 官方给出如下说法。 Hooks are a new feature proposal that lets you use state and other React features without writing a class. Hook是一项新功能提案，可让您在不编写类的情况下使用状态和其他React功能。 在之前的react版本中，组件大多以Class的方式进行声明，以便处理组件的状态和一些功能特性，其中也有很多坑，很多繁琐的写法，在新的提案中将会简化很多。 新的提案中提出了好多Hook Basic Hooks useState useEffect useContext Additondal Hooks useReducer useCallback useMemo useRef useImperativeMethods useMutationEffect useLayoutEffect Hooks 使用的前提是 必须在函数中使用，因此使用hooks进行开发意味着所有的组件都将以函数的方式呈现。在函数外使用hooks会报错 Uncaught Error: Hooks can only be called inside the body of a function component. Basic HooksuseState基础用法 1const [state, setState] = useState(initialState) setState是一个函数，接受一个初始状态，返回一个数组，第一项是state的值，第二项是改变这个state值的方法 初始状态一般是一个普通的值，但是如果初始的值需要经过复杂的计算得来的话，可以传递函数给它 1234const [state, setState] = useState(() =&gt; &#123; const initState = Math.round(Math.random() * 10) return initState&#125;) setState方法用来更新state的，一般情况下传入新的state值即可 1setState(5) 如果使用先前状态计算新状态，则可以将函数传递给setState。 该函数将接收先前的值，并返回更新的值。 1setState(prevState =&gt; prevState + 1) 更新状态方法的使用和class方式的组件中的 this.setState 很相似，但是Hooks 中只能更新单一的状态，不支持合并更新状态对象，也就是说，每一个state 都需要通过 useState 进行初始化，每一个状态对应一个值和一个状态更新的方法，一个组件中有多个状态多次调用即可。 12const [count, setCount] = useState(0)const [name, setName] = useState('sqb') 如果想更新多个状态，可以给 useState 传入对象， 更新状态的时候根据函数和扩展语法相结合来实现。 12345678910111213141516171819202122import React, &#123; useState &#125; from 'react'const initialState = &#123; name: 'undo', age: 26&#125;export default (&#123;initialCount = 0&#125;) =&gt; &#123; const [count, setCount] = useState(initialCount) const [option, setOption] = useState(initialState) return ( &lt;div&gt; &lt;p&gt;Name: &#123; option.name &#125; Age: &#123;option.age&#125; Count: &#123; count &#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setOption(preState =&gt; &#123; return &#123;...preState, ...&#123;name: 'sqb'&#125;&#125; &#125;)&#125;&gt;setName&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(0)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125; 后续可以通过 useReducer 来实现，后面再讲。 useEffect函数中可以避免之前在 componentDidMount 、 componentDidUpdate 中的订阅，计时器等一些与副作用的操作，这些操作之前都需要在 componentWillUnmount 中取消订阅或者清理定时器，那么这个hook，将可以减少一些重复繁琐的操作。 相反，使用useEffect。传递给useEffect的函数将在渲染提交到屏幕后运行。将效果视为从React的纯粹功能性世界进入命令式世界的逃脱舱。 默认情况下，效果在每次完成渲染后运行，但您可以选择仅在某些值发生更改时触发它。 123456789101112131415import React, &#123; useState, useEffect &#125; from 'react'export default () =&gt; &#123; const [num, setCount] = useState(0) useEffect(() =&gt; &#123; setInterval(() =&gt; &#123; setCount(num + 1) &#125;, 2000) &#125;) return ( &lt;div&gt; &lt;p&gt;Interval Count: &#123; num &#125;&lt;/p&gt; &lt;/div&gt; )&#125; 这样就实现了一个组件挂载即开启定时器的功能，但是仅仅是这样并不完整，当组件卸载的时候并不会清除定时器，控制台会报错。 通常，效果会创建在组件离开屏幕之前需要清理的资源，例如订阅或计时器ID。为此，传递给useEffect的函数可能会返回一个清理函数。 12345678useEffect(() =&gt; &#123; let timer = setInterval(() =&gt; &#123; setCount(num + 1) &#125;, 2000) return () =&gt; &#123; clearInterval(timer) &#125;&#125;) 这样在组件卸载的时候就就会清理掉定时器。清除功能在从UI中删除组件之前运行，以防止内存泄漏。此外，如果组件呈现多次（通常如此），则在执行下一个效果之前会清除先前的效果。在示例中，这意味着每次更新都会清理之前的定时器再创建新的定时器，哪怕是一些不相关的state发生变化也会做上面的事。 但是，在某些情况下，这样做是没必要的，性能是浪费的，例如我们有别的state数据发生更新与这个定时器毫无关系，那么这时候就没必要清理定时器再去重新开启。 要实现此功能，请将第二个参数传递给useEffect，它是效果所依赖的值数组。只有当数组中的值发生变化了才会使useEffect再次执行。 123456789101112131415161718192021import React, &#123; useState, useEffect &#125; from 'react'export default () =&gt; &#123; const [num, setCount] = useState(0) const [name, setName] = useState('undo') useEffect(() =&gt; &#123; let timer = setInterval(() =&gt; &#123; setCount(num + 1) &#125;, 5000) return () =&gt; &#123; console.log('timer', timer) clearInterval(timer) &#125; &#125;, [num]) return ( &lt;div&gt; &lt;p&gt;Interval Count: &#123; num &#125;&lt;/p&gt; &lt;p onClick=&#123;()=&gt; &#123;setName(name === 'undo' ? 'sqb' : 'undo')&#125;&#125;&gt;Name: &#123; name &#125;&lt;/p&gt; &lt;/div&gt; )&#125; 这样只有num值发生变化的时候才会重置定时器，当操作那么的时候Effect并不会不行，就可以避免一些不必要的清理，订阅和日志等同理。 那如果想要只在组件挂载的时候调用，也就是 componentDidMount 相同的功能也非常简单，给useEffect 第二个参数传一个空数组即可，表示告诉React这个效果不依赖于组件中的任何值，因此这个效果只会在组件挂载的时候运行。 也可以把它作为一个工具函数，在组件挂载和卸载的时候做一些操作的时候能够用到，例如在组件挂载的时候改变页面的标题，卸载的时候再重置到默认标题 1234567891011// 工具函数import &#123; useEffect &#125; from 'react'export function useDocumentTitle(title) &#123; useEffect( () =&gt; &#123; document.title = title; return () =&gt; (document.title = \"React App\") &#125;, [title] )&#125; 123456789101112// 工具函数在组件中的使用import React from 'react'import &#123; useDocumentTitle &#125; from '../utils/index'export default () =&gt; &#123; useDocumentTitle('Interval') return ( &lt;div&gt; &lt;p&gt;Interval Count&lt;/p&gt; &lt;/div&gt; )&#125; 这个组件挂载的时候将页面标题设置为 ‘Interval’, 这个组件 销毁的时候将页面的标题重置回”React App”。 useContext接受上下文对象（从React.createContext返回的值）并返回当前上下文值，由给定上下文的最近上下文提供程序给出。有点类似Provider组件的功能。 12345678910111213// 外层组件import React from 'react'import DeepChild from './DeepChild'export const Context = React.createContext(null)const someVal = &#123; a: 'Context-a', b: 'Context-b' &#125;export default () =&gt; &#123; return ( &lt;Context.Provider value=&#123;someVal&#125;&gt; &lt;DeepChild&gt;&lt;/DeepChild&gt; &lt;/Context.Provider&gt; )&#125; 12345678910// DeepChild.js 子组件import React, &#123; useContext &#125; from 'react'import &#123; Context &#125; from './index'export default () =&gt; &#123; const aa = useContext(Context) console.log(aa) // &#123; a: 'Context-a', b: 'Context-b' &#125; return ( &lt;div&gt;&#123;aa.a&#125;&lt;/div&gt; )&#125; 在子组件中可以通过 useContext 拿到外层组件中通过上下文定义的数据，后续结合 useReducer 几乎就可以实现 react-redux 的功能了。 Additondal HooksuseReducer它是useState的替代方案，和redux的作用几乎一样，用来集中管理状态，而且基本流程和常用语法也是和redux一致的。它是一个函数 接受一个reducer，reducer我们也很熟悉了 （state，action）=&gt; newState ，一个接受当前状态和action指令返回新的状态的函数。 所以使用起来也是很顺手的，下面就是一个简单的todo的例子。 1234567891011121314151617181920// reducer.jsimport &#123; useReducer &#125; from 'react'const initState = &#123; name: 'undo', list: []&#125;const reducer = (state, action) =&gt; &#123; const &#123; type &#125; = action switch(type) &#123; case 'change_name': return Object.assign(&#123;&#125;, state, &#123;name: action.name&#125;) case 'add': return Object.assign(&#123;&#125;, state, &#123;list: [...state.list, action.data]&#125;) default: return state &#125;&#125;export default () =&gt; useReducer(reducer, initState) 123456789101112131415161718192021222324252627// todo.jsimport React from 'react'import todoReducer from './reducer'export default () =&gt; &#123; const [state, dispatch] = todoReducer() const &#123;name, list&#125; = state return ( &lt;div&gt; &#123; list &amp;&amp; list.length &gt; 0 &amp;&amp; list.map((item, index) =&gt; ( &lt;p key=&#123;index&#125;&gt;待办事项 &#123;item&#125;&lt;/p&gt; )) &#125; &lt;p&gt;&#123;name&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123;type: 'add', data: list.length + 1&#125;) &#125;&#125;&gt; Add todo &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; dispatch(&#123;type: 'change_name', name: name === 'songqibin' ? 'undo' : 'songqibin'&#125;) &#125;&#125;&gt; Change name &lt;/button&gt; &lt;/div&gt; )&#125; 很简单，和redux的用法几乎一样，useReducer 还支持第三个参数，可以进行一些初始化的操作。就像redux在初始化的时候会先执行一个 init 的action一样。 1export default () =&gt; useReducer(reducer, initState, &#123;type: 'add', data: 3&#125;) 其实如果再写一个合并reducer的函数，那么几乎可以完全实现redux的功能了。 useRefuseRef返回一个可变的ref对象，其.current属性被初始化为传递的参数（initialValue）。返回的对象将持续整个组件的生命周期。 初始化传递的参数赋值给了ref对象的current属性，组件挂载完成之后current将指向指定的dom元素。 123456789101112131415161718import React, &#123; useRef &#125; from 'react'export default () =&gt; &#123; const inputEle = useRef(null) console.log(inputEle.current) // null const onButtonClick = () =&gt; &#123; console.log(inputEle) // input inputEle.current.focus() &#125; const onHandleChange = () =&gt; &#123; console.log(inputEle.current.value) &#125; return ( &lt;div&gt; &lt;input ref=&#123;inputEle&#125; type=\"text\" onChange=&#123;onHandleChange&#125; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/div&gt; )&#125; useRef 可以赋值初始值，可以避免直接使用ref方式造成的ref丢失的现象，以后的开发可能需要尽可能的使用它。 useImperativeMethodsuseImperativeMethods自定义使用ref时公开给父组件的实例值，也就是说通过这个函数可以将子组件的实例提供给父组件访问调用。useImperativeMethods应与forwardRef一起使用。 12345678910111213141516// 子组件import React, &#123; useRef, useImperativeMethods, forwardRef &#125; from 'react'const FancyInput = (props, ref) =&gt; &#123; const inputEle = useRef(null) useImperativeMethods(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputEle.current.focus() &#125; &#125;)) const onHandleChange = () =&gt; &#123; console.log(inputEle.current.value) &#125; return &lt;input ref=&#123;inputEle&#125; type=\"text\" onChange=&#123;onHandleChange&#125; /&gt;&#125;export default forwardRef(FancyInput) 12345678910111213// 父组件的使用， 在父组件中操作子组件让其聚焦import React, &#123; useState, useRef &#125; from 'react';import UseImperativeMethods from './UseImperativeMethods'export default () =&gt; &#123; const fancyInputRef = useRef() return ( &lt;div className=\"App\"&gt; &lt;UseImperativeMethods ref=&#123;fancyInputRef&#125;&gt;&lt;/UseImperativeMethods&gt; &lt;button onClick=&#123;() =&gt; &#123;fancyInputRef.current.focus()&#125;&#125;&gt;Focus child input&lt;/button&gt; &lt;/div&gt; )&#125; useCallback返回一个memoized回调。 传递内联回调和一组输入。 useCallback将返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。当将回调传递给依赖于引用相等性的优化子组件以防止不必要的渲染（例如，shouldComponentUpdate）时，这非常有用。 输入数组不作为参数传递给回调。但从概念上讲，这就是它们所代表的内容：回调中引用的每个值也应出现在输入数组中。将来，一个足够先进的编译器可以自动创建这个数组。 1234567const memoizedCallback = useCallback( () =&gt; &#123; console.log('useCallback', count) return count % 3 === 0 ? true : false &#125;, [count],) useMemo返回一个memoized值。和useCallback用法类似。 传递“创建”功能和输入数组。 useMemo只会在其中一个输入发生更改时重新计算memoized值。此优化有助于避免在每个渲染上进行昂贵的计算。 如果未提供数组，则只要将新函数实例作为第一个参数传递，就会计算新值。 输入数组不作为参数传递给函数。但从概念上讲，这就是它们所代表的内容：函数内部引用的每个值也应出现在输入数组中。将来，一个足够先进的编译器可以自动创建这个数组。 useMutationEffect签名与useEffect相同，但在更新兄弟组件之前，它在React执行其DOM突变的同一阶段同步触发。使用它来执行自定义DOM突变。 在可能的情况下首选标准useEffect以避免阻止视觉更新。 避免在useMutationEffect中读取DOM。如果这样做，您可以通过引入布局thrash来导致性能问题。在读取计算样式或布局信息时，useLayoutEffect更合适。 useLayoutEffect签名与useEffect相同，但在所有DOM突变后同步触发。使用它来从DOM读取布局并同步重新渲染。在浏览器有机会绘制之前，将在useLayoutEffect内部计划的更新将同步刷新。 在可能的情况下首选标准useEffect以避免阻止视觉更新。 如果您正在从类组件迁移代码，则useLayoutEffect会在与componentDidMount和componentDidUpdate相同的阶段触发，因此如果您不确定Hook要使用哪种效果，则可能风险最小。","tags":[{"name":"react","slug":"react","permalink":"/tags/react/"},{"name":"react-hooks","slug":"react-hooks","permalink":"/tags/react-hooks/"}]},{"title":"redux源码 - 个人理解","date":"2018-09-11T16:00:00.000Z","path":"redux_understanding/","text":"最近项目中常用到redux，闲暇时间阅读了以下redux源码，结合自己使用的经验和习惯再去看源码以及设计者的设计思想，使得自己对redux的理解更加清晰，同时也对阅读源码有了一定的经验。 为什么想写这篇文章？ 本来是在新的团队中参与项目开发，但是项目中的redux使用的流程和文件目录划分相对混乱，想结合自己的经验做一些改善，但是发现要做到这一点，需要先对redux有个清晰的认识，才能更好的完成这个目标。 首先看看redux库的index.js文件的导出 1234567export &#123; createStore, combineReducers, bindActionCreators, applyMiddleware, compose&#125; 其实这样看是很简单的，redux提供的API就这么几个，创建store、合并redudcer、action创造器、应用中间件工具函数compose。 下面一一来看，先来看一下redux的核心API createStore 1. createStore先来说一下这个函数，接受参数是reducer，preloadedState，enhancer。 reducer，是一个函数，传入当前的state和action，返回新的state，后面combineReducers的时候细说。 preloadedState，可以理解为初始化的state。 enhancer是中间件函数，applyMiddleware函数的返回值。 12345678910export default function createStore(reducer, preloadedState, enhancer) &#123; // 一堆的逻辑 return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 其实这个函数导出的就是我们要用的store对象，常用的API是dispatch、subscribe、getState。 下面再继续深挖各个函数 1.1 getState这个函数很简单，作用就是返回当前的状态 123function getState() &#123; return currentState&#125; 1.2 dispatch先来简单看一下这个函数的骨架 123456789101112131415161718function dispatch(action) &#123; // 很多的错误检测和逻辑优化 // currentListeners、nextListeners是局部的变量，监听着 try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; 这个函数接受一个action，然后执行reducer更新state，然后让每个订阅者执行。 1.3 subscribe12345678910111213141516171819202122function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; 这个函数是用来订阅state变化的， 接受一个订阅者，然后将该订阅者加入到订阅者列表中。订阅完成后返回一个取消订阅的函数，一般在组件销毁的时候调用，可提高性能。 1.4 replaceReducer12345678function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.INIT &#125;)&#125; 用来更行reducer的，开发中很少用到这个API。 所以综合以上几个函数，可以将createStore函数的核心简化理解为以下这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 初始化store的actionexport const ActionTypes = &#123; INIT: '@@redux/INIT'&#125;export default function createStore(reducer, preloadedState, enhancer) &#123; let currentReducer = reducer // 当前的执行者currentReducer let currentState = preloadedState // 当前的state let currentListeners = [] // 订阅者列表 let nextListeners = currentListeners // 新的订阅者列表 let isDispatching = false // action派发状态，可以优化性能 // 更新订阅者列表 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // 获取当前state function getState() &#123; return currentState &#125; // 订阅 function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; // 派发action function dispatch(action) &#123; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; // 更新reducer function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.INIT &#125;) &#125; // 初始化store dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer &#125;&#125; 函数最终返回了一个对象，通常我们会命名为store，store.dispatch()这样去使用。 2. combineReducers开发中统通常我们会把reducer按功能或按模块进行拆分成多个简单的reducer，combineReducers 的功能很简单，把多个简单的reducer进行合并，合并成一个大的reducer，一般的应用中都会用到。 单一的reducer一般是这样的： 12345678910111213141516import &#123; GET_TASK_LIST &#125; from '../actions/taskList'let initState = &#123; taskList: []&#125;export default (state = initState, action = &#123;&#125;) =&gt; &#123; const &#123; type &#125; = action; switch (type) &#123; case GET_TASK_LIST: return &#123;...state, taskList: action.list &#125;; default: return state; &#125;&#125; combineReducers 的功能就是把多个这样的reducer进行合并，进行统一管理。 combineReducers 实现的核心代码如下： 12345678910111213141516171819202122232425export default function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; const finalReducerKeys = Object.keys(finalReducers) return function combination(state = &#123;&#125;, action) &#123; let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; 可以看出函数接受的是一个reducers对象，每个key代表的是一个小的reducer，combineReducers返回一个新的reducer，每次这个新的reducer执行会遍历key组成的数组，并执行每个key对应的reducer，并将返回的新的state按照key进行合并组装成新的state对象。 1234567891011121314combineReducers(&#123; tranning, taskList&#125;)// 返回的state将会是&#123; tranning: &#123;&#125;, taskList: &#123;&#125; &#125;// 要取得对应的state值需要向这样取state.taskList.xxxstate.tranning.xxx 注意：一般开发的时候会将action和reducer进行对应拆分，这样合并之后就可能会出现action.type重复的现象，导致reducer执行混乱。所以在写action的时候需要按模块名或者功能进行区分 3. bindActionCreators这个API运用场景很少，以至于我也不怎么理解它，官方是这样实现的： 123456789101112131415function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args))&#125;export default function bindActionCreators(actionCreators, dispatch) &#123; const keys = Object.keys(actionCreators) const boundActionCreators = &#123;&#125; for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; 把action creators转成拥有同名 keys 的对象，使用 dispatch 把每个 action creator 包围起来，这样可以直接调用它们。唯一使用 bindActionCreators 的场景是当你需要把 action creator往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch传给它。为方便起见，你可以传入一个函数作为第一个参数，它会返回一个函数。 4. applyMiddleware这个函数是使用中间件使dispatch函数更加强大，一般在需要在派发墙厚做一些额外操作的时候会用到它，比如dispatch一个函数等。 12345678910111213141516171819export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 它将所有的中间件进行合并，并重写了createStore返回的dispatch函数，然后覆盖掉store的dispatch。 返回的函数也就是enhancer，传给createStore。 1const store = createStore(reducer, preloadedState, enhancer) 5. compose工具函数，将多个相互依赖的函数进行合并，在applyMiddleware函数中有用到。 1234567891011export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 这是redux的核心实现方式，也都是源码中的代码片段，源码中有很多的工具函数和错误类型的判断，以及各种参数类型的兼容，可以在源码中进行查看。","tags":[{"name":"redux","slug":"redux","permalink":"/tags/redux/"}]},{"title":"react-native 文件下载","date":"2018-07-10T16:00:00.000Z","path":"rn_simple_download_manager/","text":"在做安卓App的时候，遇到一个需求下载pdf，下载完成在通知栏提示，并且能够打开下载的文件。 其实这个需求是很常见和普通的需求，但是刚做 RN 项目不久，遇到的这类问题也不是很会处理，特此记录一下。 本次是使用了一个 react-native 包, react-native-simple-download-manager 1. 安装用以下命令进行包安装 123yarn add react-native-simple-download-manager// or npm i react-native-simple-download-manager --save link 一下 1react-native link react-native-simple-download-manager 2. android 文件的修改link 之后 android 下的文件会做以下改动 1. android/app/src/main/java/[…]/MainApplication.java添加 import com.masteratul.downloadmanager.ReactNativeDownloadManagerPackage; 添加 new ReactNativeDownloadManagerPackage() 到 getPackages() 中 2. android/settings.gradle12include ':react-native-simple-download-manager'project(':react-native-simple-download-manager').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-simple-download-manager/android') 3. android/app/build.gradle1compile project(':react-native-simple-download-manager') 3. 使用文件下载使用的是 downloadManager.download 方法 123456789101112131415161718192021222324import downloadManager from 'react-native-simple-download-manager'download = async (orderId) =&gt; &#123; const url = 'https://p.upyun.com/docs/cloud/demo.jpg' const headers = &#123;'Authorization': 'Bearer abcsdsjkdjskjdkskjd'&#125;; const config = &#123; downloadTitle: '图片下载', downloadDescription: '图片下载完成', saveAsName: orderId + '.pdf', allowedInRoaming: true, allowedInMetered: true, showInDownloads: true, external: false, // when false basically means use the default Download path (version ^1.3) path: 'Download/' // if \"external\" is true then use this path (version ^1.3) &#125; downloadManager.download(url, headers, config).then((response) =&gt; &#123; console.log(url) console.log('Download success!') ToastAndroid.showWithGravity('图片下载成功', ToastAndroid.SHORT, ToastAndroid.CENTER) &#125;).catch(err =&gt; &#123; console.log(err) ToastAndroid.showWithGravity('图片下载失败，请重新下载', ToastAndroid.SHORT, ToastAndroid.CENTER) &#125;)&#125; 以上是简单使用，config 中 external 为 false 时，只会下载，并在通知栏进行通知。 效果图如下 配置项解析： url： 文件下载地址 headers： 请求头信息，需要身份认证的可以设置 Cookie config： 配置信息 downloadTitle： 通知栏通知标题 downloadDescription： 描述信息 saveAsName： 文件保存的名字 external： 是否保存到SD卡 path： 文件保存的路径，external 为 true 才有效 如果要保存到设备文件管理中，需要添加权限文件读写权限 需要在 android/app/src/main/AndroidManifest.xml 中添加权限 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; 使用 PermissionsAndroid 检测是否开启权限 12345678910111213141516import &#123;PermissionsAndroid&#125; from 'react-native'let authorizedWriteSD = await PermissionsAndroid.request(PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE).then(authorized =&gt; authorized)if (authorizedWriteSD !== 'granted') &#123; ToastAndroid.showWithGravity('请开启访问设备上照片、媒体内容和文件权限，否则无法保存文件', ToastAndroid.SHORT, ToastAndroid.CENTER) return&#125;const config = &#123; downloadTitle: '电子发票下载', downloadDescription: '电子发票下载完成', saveAsName: orderId + '.pdf', allowedInRoaming: true, allowedInMetered: true, showInDownloads: true, external: true, // when false basically means use the default Download path (version ^1.3) path: 'Download/' // if \"external\" is true then use this path (version ^1.3) &#125; 设置带身份验证的下载 1234const url = CONFIG.PREFIX + `order/download_pdf?order_id=$&#123;orderId&#125;`let userInfoToken = await localStorage.getItem('userInfoToken')const headers = &#123;'Cookie': userInfoToken&#125;... 4. 其他API download queueDownload attachOnCompleteListener cancel checkStatus 具体可以查看 https://github.com/master-atul/react-native-simple-download-manager/blob/master/index.js","tags":[{"name":"react-native","slug":"react-native","permalink":"/tags/react-native/"}]},{"title":"git-flow 工作流程","date":"2018-07-03T16:00:00.000Z","path":"git_git_flow/","text":"一、前言git 最强大的就是其分支功能，但是如何分支才能更有效的提高开发效率，减少因为代码合并带来的问题，需要一个分支模型来规范，其实在git flow 出现之前，已经有分支模型理论流程，当时是根据此理论，手动的按照规范操作分支，git flow 出现之后，将一部分操作流程简化为命令，并没有增加新的功能，只是简化了操作。 二、git-flow 简介安装git-flow后，你将会拥有一些扩展命令。这些命令会在一个预定义的顺序下自动执行多个操作。git-flow 并不是要替代 Git，它仅仅是非常聪明有效地把标准的 Git 命令用脚本组合了起来。严格来讲，你并不需要安装什么特别的东西就可以使用 git-flow 工作流程。你只需要了解，哪些工作流程是由哪些单独的任务所组成的，并且附带上正确的参数，以及在一个正确的顺序下简单执行那些对应的 Git 命令就可以了。当然，如果你使用 git-flow 脚本就会更加方便了，你就不需要把这些命令和顺序都记在脑子里。 三、安装目前流行的是 avh 版本的git-flow1234# 稳定版brew install git-flow-avh# 开发板brew install git-flow-avh --HEAD 四、初始化项目123# cd /pass/to/your/project# 执行下面的命令，不需要执行 git initgit flow init 五、分支模型用 git flow 初始化工程目录完成后，只能看到两个分支： Gitflow使用两个分支来记录项目开发的历史，而不是使用单一的master分支。在Gitflow流程中，master只是用于保存官方的发布历史，而develop分支才是用于集成各种功能开发的分支。使用版本号为master上的所有提交打标签（tag）也很方便。事实上，Gitflow流程就是围绕这两个特点鲜明的分支展开的。 master 分支用于上线的分支，保护性分支，只包含经过测试的稳定代码，开发人员不能直接工作在此分支上，也不能直接提交改动到 master 分支上。 develop分支是开发人员进行任何新的开发的基础分支，当开始一个新的feature 分支的时候，要从 develop 分出去；另外此分支也汇集所有的已完成的功能，等待合并到 master 分支上线。 上面两个分支被称为长期分支 ，存在于项目的整个生命周期中，其他分支，是临时性的，根据需要来创建，当完成了自己的任务后，就会被删掉。 feature 分支平常的开发工作使用最频繁的分支。每一个新功能的开发都应该各自使用独立的分支。为了备份或便于团队之间的合作，这种分支也可以被推送到中央仓库。但是，在创建新的功能开发分支时，父分支应该选择develop（而不是master）。当功能开发完成时，改动的代码应该被合并（merge）到develop分支。功能开发永远不应该直接牵扯到master。 1. 开始一个feature分支如下命令会创建一个名为”feature/” 的功能分支，该分支默认从 develop检出，在做功能性开发的时候，检出一个独立的分支，是版本控制中一个重要 的原则。 12# git-flow 创建 feature 分支$ git flow feature start &lt;branch-name&gt; 2. 完成一个feature分支12# git-flow 完成一个 feature 分支 $ git flow feature finish &lt;branch-name&gt; 该命令会把我们在当前分支的代码整合到‘develop’分支中去，之后，git-flow 会进行清理操作，删除当下完成的功能分支，将分支切换到‘develop’。 release 分支一旦develop分支积聚了足够多的新功能（或者预定的发布日期临近了），你可以基于develop分支建立一个用于产品发布的分支。这个分支的创建意味着一个发布周期的开始，也意味着本次发布不会再增加新的功能——在这个分支上只能修复bug，做一些文档工作或者跟发布相关的任务。在一切准备就绪的时候，这个分支会被合并入master，并且用版本号打上标签。另外，发布分支上的改动还应该合并入develop分支——在发布周期内，develop分支仍然在被使用（一些开发者会把其他功能集成到develop分支）。使用专门的一个分支来为发布做准备的好处是，在一个团队忙于当前的发布的同时，另一个团队可以继续为接下来的一次发布开发新功能。 1.创建一个release分支当你认为现在在 “develop” 分支的代码已经是一个成熟的 release 版本时，这意味着：第一，它包括所有新的功能和必要的修复；第二，它已经被彻底的测试过了。如果上述两点都满足，那就是时候开始生成一个新的 release 了： 12$ git flow release start 1.1.5Switched to a new branch 'release/1.1.5' 请注意，release 分支是使用版本号命名的。这是一个明智的选择，这个命名方案还有一个很好的附带功能，那就是当我们完成了release 后，git-flow 会适当地_自动_去标记那些 release 提交。 有了一个 release 分支，再完成针对 release 版本号的最后准备工作（如果项目里的某些文件需要记录版本号），并且进行最后的编辑。 2. 完成一个release分支1$ git flow release finish 1.1.5 这个命令会完成如下一系列的操作： 首先，git-flow 会拉取远程仓库，以确保目前是最新的版本。 然后，release 的内容会被合并到 “master” 和 “develop” 两个分支中去，这样不仅产品代码为最新的版本，而且新的功能分支也将基于最新代码。 为便于识别和做历史参考，release 提交会被标记上这个 release 的名字（在我们的例子里是 “1.1.5”）。 清理操作，版本分支会被删除，并且回到 “develop”。 从 Git 的角度来看，release 版本现在已经完成。依据你的设置，对 “master” 的提交可能已经触发了你所定义的部署流程，或者你可以通过手动部署，来让你的软件产品进入你的用户手中。 hotfix分支发布后的维护工作或者紧急问题的快速修复也需要使用一个独立的分支。这是唯一一种可以直接基于master创建的分支。一旦问题被修复了，所做的改动应该被合并入master和develop分支（或者用于当前发布的分支）。在这之后，master上还要使用更新的版本号打好标签。 1. 创建一个hotfix分支1$ git flow hotfix start missing-link 这个命令会创建一个名为“hotfix/missing-link” 的分支。因为这是对产品代码进行修复，所以这个hotfix分支是基于“master”分支。 这也是和 release 分支最明显的区别，release 分支都是基于 “develop” 分支的。因为你不应该在一个还不完全稳定的开发分支上对产品代码进行地修复。 就像 release 一样，修复这个错误当然也会直接影响到项目的版本号！ 2.完成一个hotfix分支在把我们的修复提交到hotfix分支之后，就该去完成它了： 1$ git flow hotfix finish missing-link 这个过程非常类似于发布一个 release 版本： 完成的改动会被合并到 “master” 中，同样也会合并到 “develop” 分支中，这样就可以确保这个错误不会再次出现在下一个 release 中。 这个 hotfix 会被标记起来以便于参考。 这个 hotfix 分支将被删除，然后切换到 “develop” 分支上去。 还是和产生 release 的流程一样，现在需要编译和部署你的产品（如果这些操作不是自动被触发的话）。 六、总结主要分支master: 项目的主要分支，对外的第一门面。所有人浏览项目，使用项目，第一时间看到的是master。永远处在即将发布(production-ready)状态。develop: 处于功能开发的最前线的版本，查看develop分支就能知道下一个发布版本有哪些功能了。develop一开始是从master里分出来的，并且定期会合并到master里，每一次合并到master，表示我们完成了一个阶段的开发，产生一个稳定版。同样的，develop下也不建议直接开发代码，develop代表的是已经开发好的功能的回归版本。最后，在适当的时候，由合适的人，合并到master，作为下一个稳定版本。 feature的作用是为每一个新功能从develop里创建出来的一个分支。例如小明和小白分别做两个不相干的功能，就应该分别创建两个分支，各自开发完以后，先后合并到develop里，这就叫做回归。 辅助分支feature: 开发新功能的分支, 基于 develop, 完成后 merge 回 developrelease: 准备要发布版本的分支, 也基于 develop, 完成后 merge 回 develop 和 masterhotfix: 修复 master 上的问题, 等不及 release 版本就必须马上上线. 基于 master, 完成后 merge回 master 和 develop 本文转载自: https://www.lishuaishuai.com/tool/791.html","tags":[{"name":"Git","slug":"Git","permalink":"/tags/Git/"}]},{"title":"Promise 简单介绍","date":"2018-06-21T16:00:00.000Z","path":"js_promise/","text":"Promise对于每一个前端工程师来说都不陌生,在项目开发中的使用也是越来越频繁,各大主流浏览器厂商也是对它做了很好的支持. Promise的出现解决了回调地狱的问题, 同时多个异步任务同时执行可以节省时间. 1. Promise简介Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。 什么时候会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做,常见的比如网络请求、文件读取等. 传统的异步操作都是传回调函数,异步完成后执行回调,promise就是为了改变这种模式,把异步中使用回调函数的场景改为了.then()、.catch()等函数链式调用的方式,避免回调地狱,基于promise可以把复杂的异步回调处理方式进行模块化. 以ajax为例,传统的异步写法: 123456789101112131415ajax(method, url, successFun, failFun)&#123; var xmlHttp = new XMLHttpRequest() xmlHttp.open(method, url) xmlHttp.send() xmlHttp.onload = function () &#123; if (this.status == 200 ) &#123; successFun(this.response) &#125; else &#123; failFun(this.statusText) &#125; &#125; xmlHttp.onerror = function () &#123; failFun(this.statusText) &#125;&#125; 尝试改写成promise的方式 1234567891011121314151617ajaxPromise(method, url, successFun, failFun)&#123; return new Promise(function(resolve, reject)&#123; var xmlHttp = new XMLHttpRequest() xmlHttp.open(method, url) xmlHttp.send() xmlHttp.onload = function () &#123; if (this.status == 200 ) &#123; resolve(this.response) &#125; else &#123; reject(this.statusText) &#125; &#125; xmlHttp.onerror = function () &#123; reject(this.statusText) &#125; &#125;)&#125; 然后就可以链式使用了 1ajaxPromise('get','www.xxx.com').then(successFun, failFun) 2. Promise原理分析promise原理并不难,它内部有三个状态，分别是pending,fulfilled和rejected . Pending Promise对象实例创建时候的初始状态 Fulfilled 可以理解为成功的状态 Rejected 可以理解为失败的状态 pending是对象创建后的初始状态,当对象fulfill（成功）时变为fulfilled,当对象reject（失败）时变为rejected.且只能从pengding变为fulfilled或rejected,之后就不会再次发生变化 ,不能逆向或从fulfilled变为rejected 、从rejected变为fulfilled. then 方法就是用来指定Promise对象的状态改变时确定执行的操作,resolve 时执行第一个函数onFulfilled,reject 时执行第二个函数onRejected 3. Promise 简单模拟12345678910111213141516171819202122class Promise &#123; constructor(fn) &#123; fn((data)=&gt; &#123; this.success(data) &#125;, (error)=&gt; &#123; this.error() &#125;) &#125; resolve(data) &#123; this.success(data) &#125; reject(error) &#123; this.error(error) &#125; then(success, error) &#123; this.success = success this.error = error &#125;&#125; 4. Promise基本用法Promise对象拥有两个实例方法then(),catch() 和 finally,then方法返回新的promise,因此支持链式写法 1234567891011121314151617let promise = new Promise((resolve, reject) =&gt; &#123; let flag = Math.random() setTimeout(() =&gt; &#123; if(flag &gt; 0.5) &#123; resolve('success') &#125; else &#123; reject('fail') &#125; &#125;, 500)&#125;)promise.then((result) =&gt; &#123; console.log(result)&#125;, (err) =&gt; &#123; console.log(err)&#125;) // 0.5s后这里的输出可能是fail也可能是success 构造函数Promise的参数时一个函数,这个函数接收来两个参数resolve和reject,resolve和reject同时也是函数,resolve会在promise从pending转换成 Fulfilled时执行, reject会在promise从pending转换成 Rejected时执行. 4.1 Promise.prototype.catch()then()方法会返回一个新的promise,then方法将上一步的返回结果获取过来进行后续的处理,它接受两个函数作为参数，第一个函数是用来处理resolve的结果，第二个是可选的，用来处理reject的结果,then对应的参数不为函数时,会将前一promise的状态和值传递下去. 1234567891011let p = new Promise((resolve, reject) =&gt; &#123; reject(5)&#125;)let p1 = p.then((value) =&gt; &#123; console.log(value) &#125;)let p2 = p1.then((value) =&gt; &#123; console.log('fulfill ' + value)&#125;, (reason) =&gt; &#123; console.log('reject ' + reason) // reject 5&#125;) 1234567891011let p = new Promise((resolve, reject) =&gt; &#123; resolve(5)&#125;)let p1 = p.then(undefined, (value) =&gt; &#123; console.log(value) &#125;)let p2 = p1.then((value) =&gt; &#123; console.log('fulfill ' + value) // fulfill 5&#125;, (reason) =&gt; &#123; console.log('reject ' + reason) &#125;) 4.2 Promise.prototype.catch()catch()方法其实是then方法的一种语法糖,当then方法第一个参数传undefined 或者 null即可达到catch的目的 12345678910111213141516171819202122232425262728293031323334353637383940let promise = new Promise((resolve, reject) =&gt; &#123; let flag = Math.random() setTimeout(() =&gt; &#123; if(flag &gt; 0.5) &#123; resolve('success') &#125; else &#123; reject('fail') &#125; &#125;, 500)&#125;)// then处理resolve和reject的结果promise.then((result) =&gt; &#123; console.log(result)&#125;, (err) =&gt; &#123; console.log(err)&#125;)// then处理resolve,catch处理reject的结果promise.then((result) =&gt; &#123; console.log(result)&#125;).catch( (err) =&gt; &#123; console.log(err)&#125;)// 用then的方式实现catch功能promise.then((result) =&gt; &#123; console.log(result)&#125;).then(null, (err) =&gt; &#123; console.log(err)&#125;)// 用then的方式实现catch功能,捕获then中的错误异常promise.then((result) =&gt; &#123; console.log(result) throw new Error('then Error')&#125;).then(null, (err)=&gt;&#123; console.log(err)&#125;) 4.3 Promise.prototype.finally()finally() 方法返回一个Promise,在执行then()和catch()后,都会执行finally指定的回调函数.避免同样的语句需要在then()和catch()中各写一次的情况. finally() 虽然与 .then(onFinally, onFinally) 类似,它们不同的是: 调用内联函数时,不需要多次声明该函数或为该函数创建一个变量保存它. 由于无法知道promise的最终状态,所以finally的回调函数中不接收任何参数,它仅用于无论最终结果如何都要执行的情况. 与Promise.resolve(2).then(() =&gt; {}, () =&gt; {}) （resolved的结果为undefined）不同,Promise.resolve(2).finally(() =&gt; {}) resolved的结果为 2. 同样,Promise.reject(3).then(() =&gt; {}, () =&gt; {}) (resolved 的结果为undefined), Promise.reject(3).finally(() =&gt; {}) rejected 的结果为 3. 5. Promise APIPromise还有四个静态方法，分别是resolve、reject、all、race,下面一一介绍. 除了通过new Promise()的方式，我们还有两种创建Promise对象的方法,分别是Promise.resolve() 和 Promise.reject() 5.1 Promise.resolvePromise.resolve() 它相当于创建了一个立即resolve的promise对象,这个对象处于resolve状态 123456789101112let p1 = Promise.resolve('resolve')let p2 = new Promise((resolve) =&gt; &#123; resolve('resolve')&#125;)p1.then(res =&gt; &#123; console.log(res) // resolve&#125;)p2.then(res =&gt; &#123; console.log(res) // resolve&#125;) 5.2 Promise.rejectPromise.reject() 很明显它相当于创建了一个立即reject的promise对象,这个对象处于reject状态 123Promise.reject('err').catch(err =&gt; &#123; console.log(err) // err&#125;) 5.3 Promise.allPromise.all() 它接收一个promise对象组成的数组作为参数，并返回一个新的promise对象 当数组中所有的对象都resolve时，promise对象状态变为fulfilled，所有对象的resolve的value依次添加组成一个新的数组，并以新的数组作为新promise对象resolve的value 1234567Promise.all([Promise.resolve('p1'), Promise.resolve('p2'), Promise.resolve('p3')]).then((value) =&gt; &#123; console.log('fulfill', value) // fulfill [ 'p1', 'p2', 'p3' ]&#125;, (reason) =&gt; &#123; console.log('reject',reason)&#125;) 当数组中有一个对象reject时，promise对象状态变为rejected，并以当前对象reject的reason作为新promise对象reject的reason 当数组中传入了非promise对象,会依次把它们添加到新promise对象resolve时传递的数组中. 1234567891011121314Promise.all([Promise.resolve(5), 6, true, 'test', undefined, null, &#123;a:1&#125;, function()&#123;&#125;, Promise.resolve('end')]).then((value) =&gt; &#123; console.log('fulfill', value) // fulfill [ 5, 6, true, 'test', undefined, null, &#123; a: 1 &#125;, [Function], 'end' ]&#125;, (reason) =&gt; &#123; console.log('reject', reason)&#125;) 数组中的多个promise对象几乎是同时执行的,总的时间略大于用时最长的一个对象resolve的时间 12345678910111213141516let timeout = (time) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(time) &#125;, time) &#125;)&#125;console.time('promise')Promise.all([ timeout(10), timeout(60), timeout(100)]).then((values) =&gt; &#123; console.log(values) //[10, 60, 100] console.timeEnd('promise') // promise: 101.875ms&#125;) Promise.all()中即使前面reject了,所有的对象也都会执行完毕.规范中promise对象执行是不可以中断的. 5.4 Promise.racePromise.race() 它同样接收一个promise对象组成的数组作为参数,并返回一个新的promise对象 与Promise.all()不同的是,它是在数组中有一个对象（最早改变状态）resolve或reject时,就改变自身的状态,并执行相应的回调. 1234567891011121314151617181920212223let timeout = (time) =&gt; &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(time) &#125;, time) &#125;)&#125;console.time('promise')Promise.race([ timeout(10), timeout(60), timeout(100)]).then((values) =&gt; &#123; console.log(values); [10, 60, 100] console.timeEnd('promise'); // promise: 11.330ms&#125;)Promise.race([timeout(10), timeout(60), Promise.reject('error')]).then((values) =&gt; &#123; console.log(values)&#125;).catch(err=&gt;&#123; console.log(err) // error&#125;) 当数组中有非异步Promise对象或有数字、boolean、字符串、undefined、null、{a:1}、function(){}等非Promise对象时，都会直接以第一个值resolve,立即改变为Fulfilled状态 注意: promise对象即使立马改变状态,它也是异步执行的 1234567Promise.resolve(5).then((value) =&gt; &#123; console.log('test', value)&#125;)console.log('先打出来')// 先打出来// 后打出来 5","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"promise","slug":"promise","permalink":"/tags/promise/"},{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"}]},{"title":"React Native Modal组件 Android覆盖状态栏","date":"2018-06-13T16:00:00.000Z","path":"rn_modal/","text":"在App开发中经常需要做模态框，我们第一时间就会想到 React Native 的 Modal 组件，确实Modal组件很方便。但也有一些不尽人意的地方，在安卓App开发的过程中发现，Modal不会覆盖状态栏，就会导致Modal的背景色和状态栏的颜色不一致，即使是设置了沉浸式状态栏，这样破坏了App的整体性和美观。 Modal组件基本用法 属性介绍 animationType: [‘none’, ‘slide’, ‘fade’] Modal展示和收起时的动画效果 onRequestClose: Platform.OS === ‘android’ ? PropTypes.func.isRequired : PropTypes.func 安卓物理返回回调，安卓必传 onShow: func Modal组件展开完成时调用 transparent: bool Modal背景色是否透明 visible: bool 控制Modal的展开与收起 基本用法 1234567891011121314151617181920212223242526class ModalDemo extends Component &#123; state = &#123;visible: false&#125; close() &#123; this.setState(&#123;visible: false&#125;) &#125; render() &#123; return ( &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; &lt;Modal animationType='slide' transparent visible=&#123;this.state.visible&#125; onRequestClose=&#123;() =&gt; &#123; this.close() &#125;&#125;&gt; &lt;Text&gt;Modal Demo&lt;/Text&gt; &lt;/Modal&gt; &lt;TouchableOpacity onPress=&#123;()=&gt;&#123;this.setState(&#123;visible: true&#125;)&#125;&#125;&gt; &lt;Text&gt;show&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125; 简单实现Modal覆盖状态栏其实实现很简单，在Modal组件外面包一层View，设置View绝对定位，宽高‘100%’，这样View会占据整个屏幕，再设置背景，Modal透明就可以了，这个View的渲染和Modal的visible属性用同一个state来控制即可。 12345678910111213&#123; this.state.visible ? &lt;View style=&#123;&#123;position: 'absolute', width: '100%', height: '100%', backgroundColor: 'rgba(0,0,0,0.5)'&#125;&#125;&gt; &lt;Modal animationType='slide' transparent visible=&#123;this.state.visible&#125; onRequestClose=&#123;() =&gt; &#123; this.close() &#125;&#125;&gt; &lt;Text&gt;Modal Demo&lt;/Text&gt; &lt;/Modal&gt; &lt;/View&gt; : null&#125; 这样只是实现了覆盖状态栏，还需要对各个View层的点击事件作处理，以至于达到与原始Modal组件相同的效果。 基于Modal封装覆盖状态栏的Modal12345678910111213&lt;TouchableOpacity activeOpacity=&#123;1&#125; onPress=&#123;() =&gt; &#123;this.close()&#125;&#125; style=&#123;&#123; position: 'absolute',width: '100%',zIndex: 999,height: '100%',backgroundColor: 'rgba(0, 0, 0, 0.5)'&#125;&#125;&gt; &lt;Modal animationType='slide' transparent visible=&#123;this.state.visible&#125; onRequestClose=&#123;() =&gt; &#123; this.close() &#125;&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123;this.close()&#125;&#125; activeOpacity=&#123;1&#125;&gt; &lt;TouchableWithoutFeedback onPress=&#123;() =&gt; &#123;&#125;&#125;&gt; &lt;Text&gt;内容&lt;/Text&gt; &lt;/TouchableWithoutFeedback&gt; &lt;/TouchableOpacity&gt; &lt;/Modal&gt;&lt;/TouchableOpacity&gt; 这是我在开发中使用的一种实现方式，原理简单，实现比较啰嗦。 当然也可以使用大神们的组件，也有大神从安卓底层做了封装 比如这个：react native modal android实现全屏","tags":[{"name":"react-native","slug":"react-native","permalink":"/tags/react-native/"}]},{"title":"react-native开发常见问题","date":"2018-06-11T16:00:00.000Z","path":"rn_common_problem/","text":"react-native开发中常见的问题汇总，以下是我最近在项目开发中遇到的常见的问题，做以下记录以便后续项目中使用。 1. 监听网状连接状态的变化123456789101112131415161718componentDidMount () &#123; NetInfo.addEventListener('change', this.handleConnectivityChange);&#125;componentWillUnmount() &#123; NetInfo.removeEventListener('change', this.handleConnectivityChange);&#125;handleConnectivityChange() &#123; NetInfo.isConnected.fetch().then(netConnected =&gt; &#123; if (netConnected) &#123; ToastAndroid.show('网络已连接', ToastAndroid.SHORT, ToastAndroid.BOTTOM) &#125; else &#123; ToastAndroid.show('请检查网络连接', ToastAndroid.SHORT, ToastAndroid.BOTTOM) &#125; &#125;)&#125; 2. 处理特殊页面的回退按钮和物理回退事件123456789101112131415161718192021222324252627282930313233// navigation 的 didFocus willBlur事件// BackHandler 的 hardwareBackPress 事件// this.props.navigation.replace(RouterName) 路由替换// this.props.navigation.isFocused() 路由激活状态 _didFocusSubscription; _willBlurSubscription; constructor (props) &#123; super(props) this._didFocusSubscription = props.navigation.addListener('didFocus', payload =&gt; BackHandler.addEventListener('hardwareBackPress', this.onBackButtonPressAndroid)) &#125; componentDidMount () &#123; this._willBlurSubscription = this.props.navigation.addListener('willBlur', payload =&gt; &#123; BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPressAndroid) &#125;) &#125; componentWillUnmount () &#123; this._didFocusSubscription &amp;&amp; this._didFocusSubscription.remove() this._willBlurSubscription &amp;&amp; this._willBlurSubscription.remove() BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPressAndroid) &#125; onBackButtonPressAndroid = () =&gt; &#123; if (this.toRouterName) &#123; this.props.navigation.replace(this.toRouterName) return true &#125; else &#123; return false &#125; &#125;; 3. createStackNavigator, createBottomTabNavigator 路由嵌套 StackNavigator的跳转问题1234567891011121314151617// 需要给TabNavigator 重新传navigation属性 重新定义TabNavigator容器组件的router为TabNavigator的routerclass MainView extends Component &#123; static navigationOptions = &#123; header: null &#125;; render () &#123; let &#123; isMask &#125; = this.props.global const &#123; cartCount &#125; = this.props return ( &lt;View&gt; &lt;AppTabNavigator navigation=&#123;this.props.navigation&#125;/&gt; &lt;/View&gt; ) &#125;&#125;MainView.router = AppTabNavigator.router 4. tabBarOnPress 拦截tab导航的tab点击事件1234567891011121314 navigationOptions: (&#123;navigation, screenProps&#125;) =&gt; (&#123; title: '我的', tabBarIcon: (&#123;focused&#125;) =&gt; ( &lt;Image source=&#123;focused ? require('../images/ic_mine_checked.png') : require('../images/ic_mine.png')&#125; style=&#123;styles.tabIcon&#125; /&gt; ), tabBarOnPress: () =&gt; &#123; if (!screenProps.netConnected) &#123; navigation.navigate('Home') &#125; &#125;&#125;) 5. 解决锁定屏幕方向 还有键盘顶起tab导航等问题1234567891011&lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" android:configChanges=\"keyboard|keyboardHidden|orientation|screenSize\"&gt; 添加一行：android:screenOrientation=\"portrait\" 设置为portrait是锁定竖向，landscape是锁定横向 // screenProps tab导航中动态渲染数据 对象中的值可以绑定redux中的值&lt;AppTabNavigator screenProps=&#123;&#123;cartCount: cartCount&#125;&#125; navigation=&#123;this.props.navigation&#125;/&gt; 6. 监听路由事件，可以用来做双击物理回退按钮退出App等其他功能12345678910111213141516import &#123; createStackNavigator, NavigationActions &#125; from 'react-navigation'import &#123; ToastAndroid, BackHandler &#125; from 'react-native'const AppNavigator = createStackNavigator(routes, stackConfig)const defaultStateAction = AppNavigator.router.getStateForActionlet lastBackPressed = 0AppNavigator.router.getStateForAction = (action, state) =&gt; &#123; const backRouteName = state &amp;&amp; state.routes[state.routes.length - 1].routeName if (state &amp;&amp; (action.type === NavigationActions.BACK) &amp;&amp; (backRouteName === 'MainView')) &#123; if ((lastBackPressed + 2000) &lt; Date.now()) &#123; ToastAndroid.show('再按一次退出', ToastAndroid.SHORT) lastBackPressed = Date.now() return &#123; ...state &#125; &#125; BackHandler.exitApp() &#125; return defaultStateAction(action, state)&#125; 7. 解决 isMounted(…) is deprecated warning12import &#123; YellowBox &#125; from 'react-native'YellowBox.ignoreWarnings(['Warning: isMounted(...) is deprecated', 'Module RCTImageLoader']) 8. 合理使用 componentWillReceiveProps， shouldComponentUpdate12345678910111213componentWillReceiveProps (nextProps) &#123; if (!nextProps.xxx) &#123; dosomething &#125;&#125; shouldComponentUpdate (newProps, newState) &#123; if (this.props.navigation.isFocused()) &#123; return true // render &#125; else &#123; return false // not render &#125;&#125; 9. 工具类logger 和 创建store123456789101112131415import &#123; createStore, applyMiddleware, compose &#125; from 'redux'import screenTracking from './screenTrackingMiddleware'import reducer from '../reducers'import logger from 'redux-logger'const middlewares = []if (__DEV__) &#123; middlewares.push(logger)&#125;middlewares.push(screenTracking) const store = compose(applyMiddleware(...middlewares))(createStore)(reducer)export default store 10. 比较好用的第三方组件12345react-native-swiper swiper组件react-native-linear-gradient 渐变组件react-native-swipe-list-view 侧滑组件react-native-image-crop-picker 图片裁剪、调用相机和手机相册react-native-cookies 管理Cookie 11. ScrollView 组件监听滚动到底部12345678910111213_contentViewScroll (e) &#123; let offsetY = e.nativeEvent.contentOffset.y // 滑动距离 let contentSizeHeight = e.nativeEvent.contentSize.height // scrollView contentSize高度 let oriageScrollHeight = e.nativeEvent.layoutMeasurement.height // scrollView高度 if (offsetY + oriageScrollHeight &gt;= contentSizeHeight) &#123; // do something &#125;&#125;&lt;ScrollView onMomentumScrollEnd=&#123;this._contentViewScroll.bind(this)&#125; showsVerticalScrollIndicator=&#123;false&#125;&gt; &lt;/ScrollView&gt; 12. Image 使图片按宽度或者高度自适应12345678910111213141516171819class ImageAdaptive extends Component &#123; state = &#123; width: 0, height: 0 &#125; componentDidMount () &#123; Image.getSize(this.props.uri, (width, height) =&gt; &#123; let h = 330 * height / width this.setState(&#123;height: h&#125;) &#125;) &#125; render () &#123; return ( &lt;Image source=&#123;&#123;uri: this.props.uri&#125;&#125; style=&#123;[&#123;width: D(330), height: D(this.state.height)&#125;, this.props.style]&#125; /&gt; ) &#125;&#125; 13. 根据Swiper组件改装的图片预览组件12345678910111213141516171819202122&lt;Swiper loop=&#123;false&#125; index=&#123;initialSlide&#125; renderPagination=&#123;(index, total) =&gt; ( &lt;View style=&#123;styles.paginationStyle&#125;&gt; &lt;Text style=&#123;styles.paginationText&#125;&gt;&#123;index + 1&#125;/&#123;total&#125;&lt;/Text&gt; &#123; delImage ? &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; delImage &amp;&amp; delImage(index) &#125;&#125; style=&#123;styles.del&#125;&gt; &lt;Image source=&#123;require('../../images/personal/ic_preview_delete.png')&#125; style=&#123;styles.imageDel&#125; /&gt; &lt;/TouchableOpacity&gt; : null &#125; &lt;/View&gt; )&#125;&gt; &#123; images &amp;&amp; images.map((image, index) =&gt; ( &lt;TouchableOpacity style=&#123;styles.imagesItemWrapper&#125; key=&#123;index&#125; activeOpacity=&#123;1&#125; onPress=&#123;this.closeModal&#125;&gt; &lt;Image resizeMode='contain' style=&#123;styles.imagesItem&#125; source=&#123;&#123; uri: image &#125;&#125; /&gt; &lt;/TouchableOpacity&gt; )) &#125;&lt;/Swiper&gt; 14. StatusBar.currentHeight 可以从纯前端的角度兼容刘海屏沉浸式状态栏","tags":[{"name":"react-native","slug":"react-native","permalink":"/tags/react-native/"}]},{"title":"react-native android状态栏","date":"2018-06-11T16:00:00.000Z","path":"rn_statusbar/","text":"react-native 开发App的时候难免会遇到状态\b栏的\b背景颜色和字体颜色与App内容页面\b色调适配，间言之就是将状态栏颜色与App颜色一致，使用户界面更加整体。 react-native android状态栏1.android设备系统元素 导航栏：就是设备顶部的网络、时间、电量等信息栏 ActionBar: 返回按钮以及系统默认的header区域，RN开发中一般不会用到，RN中在navigation中进行定制 导航栏: 设备下方的物理返回、回桌面、选择应用程序等系统导航栏 2.状态栏的呈现形式 默认展示，一直显示手机系统的状态栏 透明状态栏，状态栏背景颜色透明，状态栏颜色与App颜色一致，用户界面更加整体。 隐藏状态栏(沉浸式)，状态栏完全隐藏，类似于全屏游戏、视频播放器的效果 2.1 默认展示系统默认状态栏样式，无法改变 2.2 透明状态栏透明状态栏很常见，大多数的App都是使用这种模式，使得状态栏颜色与App颜色一致，使用户界面更加整体，整个应用看起来更加美观。 实现透明的状态栏的方式很多： 一、使用App的主题进行配置,在app/main/res/values/styles.xml中设置主题 123456789&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"android:windowTranslucentStatus\"&gt;true&lt;/item&gt; // 设置状态栏不占据空间 // &lt;item name=\"android:windowLightStatusBar\"&gt;true&lt;/item&gt; // 设置状态栏字体颜色 &lt;/style&gt;&lt;/resources&gt; 这种方式支持api19, 即Android4.4及以上，会在App启动的时候就生效, 在App启动时有权限确认、系统弹窗等也不受影响，在弹出modal之类的深色蒙层时状态栏字体会变成成浅色 只设置&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;这种方式设置的透明状态栏，状态栏字体默认白色，无法再动态通过StatusBar改变状态栏的背景颜色,在做需要改变状态栏背景颜色的时候就比较尴尬了 再加一个&lt;item name=&quot;android:windowLightStatusBar&quot;&gt;true&lt;/item&gt;这样设置状态栏字体颜色之后，在深色modal弹出的时候字体不会动态改变成白色，但可以通过StatusBar设置barStyle来改变，实际上也不是很方便 二、android原生设置,在MainActivity的onCreate中进行设置 12345678910111213141516171819202122protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 设置透明状态栏 if (Build.VERSION.SDK_INT &gt;= 21) &#123; View decorView = getWindow().getDecorView(); int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE; decorView.setSystemUiVisibility(option); getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; // 设置透明状态栏和透明导航栏 if (Build.VERSION.SDK_INT &gt;= 21) &#123;true View decorView = getWindow().getDecorView();true int option = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATIONtrue | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREENtrue | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;true decorView.setSystemUiVisibility(option);true getWindow().setNavigationBarColor(Color.TRANSPARENT);true getWindow().setStatusBarColor(Color.TRANSPARENT);true&#125;&#125; 透明式状态栏，只有5.0及以上系统才支持，因此这里先进行了一层if判断，只有系统版本大于或等于5.0的时候才会执行下面的代码。接下来我们使用了SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，注意两个Flag必须要结合在一起使用，表示会让应用的主体内容占用系统状态栏的空间，也就是说状态栏不再占据空间。最后再调用Window的setStatusBarColor()方法将状态栏设置成透明色就可以了。 三、使用RN的StatusBar来设置，在App首次加载的页面中对状态栏进行设置 1&lt;StatusBar backgroundColor='transparent' translucent barStyle=&#123;'dark-content'&#125; /&gt; 这种方式，会在App刚启动的时候和App启动时有权限确认、系统弹窗等会先试用系统的默认状态栏，加载App页面之后再改变成上面设置的样式。好处在于可以动态进行设置状态栏的样式。 StatusBar属性简介： animated: bool 指定状态栏的变化是否应以动画形式呈现。目前支持这几种样式：backgroundColor, barStyle和hidden hidden: bool 是否隐藏状态栏。 backgroundColor: 状态栏的背景色。 translucent: bool 指定状态栏是否透明。设置为true时，应用会在状态栏之下绘制（即所谓“沉浸式”——被状态栏遮住一部分）。常和带有半透明背景色的状态栏搭配使用。 barStyle: enum(‘default’, ‘light-content’, ‘dark-content’) 设置状态栏文本的颜色。 以上几种方式都会有一个问题，状态栏不再占据空间，因此在页面布局的时候需要加 paddingTop 值为状态栏的高度。 纯前端就可以实现，这也是适配目前主流刘海屏的一种方式，利用StatusBar.currentHeight可以获取到设备状态栏的高度。 2.3 隐藏 状态栏 和 导航栏1234567super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);View decorView = getWindow().getDecorView();int option = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(option);ActionBar actionBar = getSupportActionBar();actionBar.hide(); 3. 浅色状态栏的兼容性配置目前市面上的浅色状态栏基本都是 白底黑字, 支持这种设置的有Android6.0及其以上; MIUI v6及以上, Flyme 4.0及以上 具体兼容方案如下： Flyme 4.0及以上 123456789101112131415161718192021222324252627 public static boolean FlymeSetStatusBarLightMode(Window window, boolean dark) &#123; boolean result = false; if (window != null) &#123; try &#123; WindowManager.LayoutParams lp = window.getAttributes(); Field darkFlag = WindowManager.LayoutParams.class .getDeclaredField(\"MEIZU_FLAG_DARK_STATUS_BAR_ICON\"); Field meizuFlags = WindowManager.LayoutParams.class .getDeclaredField(\"meizuFlags\"); darkFlag.setAccessible(true); meizuFlags.setAccessible(true); int bit = darkFlag.getInt(null); int value = meizuFlags.getInt(lp); if (dark) &#123; value |= bit; &#125; else &#123; value &amp;= ~bit; &#125; meizuFlags.setInt(lp, value); window.setAttributes(lp); result = true; &#125; catch (Exception e) &#123; &#125; &#125; return result;&#125; Android6.0及以上 12345678910111213 public static void setAndroidNativeLightStatusBar(Activity activity, boolean dark) &#123; //状态栏字体图标颜色 View decor = activity.getWindow().getDecorView(); if (dark) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; decor.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR //浅色状态栏(字体图标白色) | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN //contentView 全屏(置于statusbar之下) | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); &#125; &#125; else &#123; decor.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE); &#125;&#125; MIUI v6及以上 1234567891011121314151617181920212223242526272829303132333435public static boolean MIUISetStatusBarLightMode(Activity activity, boolean dark) &#123; if(Build.VERSION.SDK_INT &gt;= 24)&#123; return false; &#125; boolean result = false; Window window=activity.getWindow(); if (window != null) &#123; Class clazz = window.getClass(); try &#123; int darkModeFlag = 0; Class layoutParams = Class.forName(\"android.view.MiuiWindowManager$LayoutParams\"); Field field = layoutParams.getField(\"EXTRA_FLAG_STATUS_BAR_DARK_MODE\"); darkModeFlag = field.getInt(layoutParams); Method extraFlagField = clazz.getMethod(\"setExtraFlags\", int.class, int.class); if(dark)&#123; extraFlagField.invoke(window,darkModeFlag,darkModeFlag);//状态栏透明且黑色字体 &#125;else&#123; extraFlagField.invoke(window, 0, darkModeFlag);//清除黑色字体 &#125; result=true; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; //开发版 7.7.13 及以后版本采用了系统API，旧方法无效但不会报错，所以两个方式都要加上 if(dark)&#123; activity.getWindow().getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN| View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); &#125;else &#123; activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE); &#125; &#125; &#125;catch (Exception e)&#123; &#125; &#125; return result;&#125; 在MainActivity的onCreate中调用 123LightStatusBarUtil.FlymeSetStatusBarLightMode(this.getWindow(), false);LightStatusBarUtil.MIUISetStatusBarLightMode(this, false); LightStatusBarUtil.setAndroidNativeLightStatusBar(this, true); 总结实现透明状态栏，以上方案都没有完全兼容android 4.4以下版本，个人觉得比较合适的做法是 android设置透明状态栏 + 浅色状态栏的兼容性配置 + StatusBar 来配合控制","tags":[{"name":"react-native","slug":"react-native","permalink":"/tags/react-native/"}]},{"title":"类数组转化成数组","date":"2017-08-19T16:00:00.000Z","path":"js_list_to_array/","text":"类数组是很常见的一种数据结构, 它与数组的结构非常相似, 同时有着数组的很多特性, 很多时候会想着按数组的处理方式来使用他们, 但是我们都知道数组的方法都是封装在 Array.prototype 上的, 所以类数组是无法直接使用数组原型上的方法的, 要达到这样的目的, 就需要将类数组转化成数组. 常见的类数组有: arguments、HTMLCollection 的实例、NodeList的实例… 类数组虽然结构特点无限接近数组,但是并不是 Array的实例,所以也是无法调取数组原型上的那些方法的,想要调取的话有以下三种方案： 1. 把类数组转化为数组1234567function listToArray(likeAry) &#123; var ary = []; for (var i = 0, len = likeAry.length; i &lt; len; i++) &#123; ary[ary.length] = likeAry[i]; &#125; return ary;&#125; 通过这种方式将类数组移植成数组的实例, 就可以愉快使用数组的各种方法了 2. 直接借用数组原型上的方法(call/apply)123456789function fn() &#123; console.log(arguments); //arguments.slice(); // Uncaught TypeError: arguments.slice is not a function console.log([].slice.call(arguments)); console.log([].slice.apply(arguments)); console.log(Array.apply(null, arguments)); console.log(Array.prototype.slice.call(arguments));&#125;fn(12, 23, 34); 利用 call/apply 借用数组原型上的方法也可以达到同样的效果 注意: IE8 及以下浏览器中，DOM对象组成的类数组通过call调用slice方法没有遵循标准行为, 因此DOM元素组成的类数组无法直接通过借用slice方法转换成数组 以上两种可以做个兼容处理, 合成一种兼容比较好的函数 1234567891011function listToArray(likeAry) &#123; var ary = []; try &#123; ary = Array.prototype.slice.call(likeAry); &#125; catch (e) &#123; for (var i = 0, len = likeAry.length; i &lt; len; i++) &#123; ary[ary.length] = likeAry[i]; &#125; &#125; return ary;&#125; 3. 使用中间继承改变原型指向从其它角度理解, 为什么arguments不能直接调取数组的方法: 一个真正的数组的__proto__ 指向的是 Array.prototype, 所以可以调取这里的方法, 而arguments.__proto__ === Object.prototype, 所以只能调取对象基类原型上的方法 那么可以通过这一特性强行改变类数组实例的 __proto__ 的指向, 使其指向数组的原型 12345function fn() &#123; arguments.__proto__ = Array.prototype; console.log(arguments.reverse());&#125;fn(12, 23, 34); 注意: 在IE浏览器中,为了防止用户恶意修改内置对象的原型指向,是禁止使用proto这个属性的, 所以这只能算是一种 奇技淫巧, 了解就好但是在移动端开发中,不需要考虑IE,使用这种方式还是非常方便的","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"类数组","slug":"类数组","permalink":"/tags/类数组/"}]},{"title":"DOM映射、回流和重绘","date":"2017-08-17T16:00:00.000Z","path":"js_dom_mapping_backflow/","text":"DOM映射: 通过DOM方法获取的一个元素集合(类数组),这个集合仍然和页面的元素保持着联系,并且这个元素集合会随着页面元素的增加而增加,减少而减少,即使把这个数组转为一个数组,每个元素仍然和页面有联系,这就叫做”DOM映射” 回流: 网页内的元素的增加和删除，元素的位置的改变都会引起我们的DOM回流 重绘: 元素样式发生改变,就会把当前这个元素重新渲染一遍,进行重绘 1. DOM映射DOM映射: 通过DOM方法获取的一个元素集合(类数组), 这个集合仍然和页面的元素保持着联系, 并且这个元素集合会随着页面元素的增加而增加, 减少而减少, 即使把这个数组转为一个数组, 每个元素仍然和页面有联系,这就叫做”DOM映射” 更通俗的讲就是, 页面中的标签和js中获取到的元素对象或者元素集合是紧紧的绑定在一起的页面中html结构改变了, js中不需要重新获取, 集合里面的内容也会跟着自动改变 123456&lt;ul id=\"list\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;189&lt;/li&gt; &lt;li&gt;18&lt;/li&gt; &lt;li&gt;28&lt;/li&gt;&lt;/ul&gt; 123456789var list = document.getElementById(\"list\");// js获取到的元素集合var olis = list.getElementsByTagName(\"li\");console.log(olis.length); // 4var li = document.createElement(\"li\");list.appendChild(li);// 增加一个li后,元素集合自动改变,不需要重新获取console.log(olis.length); // 5//需要注意的是,如果将集合变成数组,这个将失效,如这里将 olis = Array.prototype.slice.call(olis);这样的话,后面的就还是4 2. 回流与重绘当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 回流必将引起重绘，而重绘不一定会引起回流。 回流何时发生：当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流： 添加或者删除可见的DOM元素； 元素位置改变； 元素尺寸改变——边距、填充、边框、宽度和高度 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 页面渲染初始化； 浏览器窗口尺寸改变——resize事件发生时； 如何减少回流、重绘 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器） 让要操作的元素进行”离线处理”,处理完后一起更新 使用DocumentFragment进行缓存操作,引发一次回流和重绘； 使用display:none技术，只引发两次回流和重绘； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存 让元素脱离动画流，减少回流的Render Tree的规模 3. 几种动态改变DOM结构的方式3.1 利用动态创建元素节点和把它追加到页面中的方式实现数据绑定123456for (var i = 0; i &lt; ary.length; i++) &#123; var cur = ary[i]; var oLi = document.createElement(\"li\"); oLi.innerHTML = \"&lt;span&gt;\" + (i + 4) + \"&lt;/span&gt;\" + cur.title; oUl.appendChild(oLi);&#125; 优势：把需要动态绑定的内容一个个的追加到页面中,对原来的元素没有任何的影响弊端：每当创建一个li,我们就添加到页面中,引发一次DOM的回流,最后引发回流的次数过多，影响性能 3.2 字符串拼接的方式字符串拼接绑定数据是工作中最常用的一种绑定数据的方式, 首先循环需要绑定的数据，然后把需要动态绑定的标签以字符串的方式拼接到一起，拼接完成后，最后统一的添加到页面中12345678910var str = \"\";for (var i = 0; i &lt; ary.length; i++) &#123; var cur = ary[i]; str += \"&lt;li&gt;\"; str += \"&lt;span&gt;\" + (i + 4) + \"&lt;/span&gt;\"; str += cur.title; str += \"&lt;/li&gt;\";&#125;oUl.innerHTML += str;// oUl.innerHTML=oUl.innerHTML(把之前的三个li以字符串的方式获取到)+str;(拼接完成的整体还是字符串,最后在把字符串统一的添加到页面中，浏览器还需要把字符串渲染成为对应的标签) 弊端：把新拼接的字符串添加到 #ul1中,原有标签绑定的事件也都消失了优势：事先把内容拼接好,最后统一添加到页面中,只引发一次回流 3.3 文档碎片创建一个文档碎片,相当于临时创建了一个容器, 先在这个容器中进行DOM结构的变化,最后将这个容器当成一个子元素插入到 html 中 12345678910var frg = document.createDocumentFragment();for (var i = 0; i &lt; ary.length; i++) &#123; var cur = ary[i]; var oLi = document.createElement(\"li\"); oLi.innerHTML = \"&lt;span&gt;\" + (i + 4) + \"&lt;/span&gt;\" + cur.title; frg.appendChild(oLi);&#125;oUl.appendChild(frg);frg = null; 弊端：我们把新拼接的字符串添加到#ul1中, 新增加的没有绑定事件优势：事先把内容拼接好,最后统一添加到页面中,也只引发一次回流, 原有的三个li绑定的事件还在 以上几种方式都会导致新增的元素绑定的事件失效, 这是因为绑定事件是给每个元素单独绑定的, 要实现子元素无论怎么改变只需要绑定一次事件, 需要用到 事件委托 或者 事件代理","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"DOM","slug":"DOM","permalink":"/tags/DOM/"}]},{"title":"css 布局技巧","date":"2017-07-22T16:00:00.000Z","path":"css_layout_skills/","text":"在写HTML页面的时候难免会遇到一些奇奇怪怪的现象，合理使用 Css 的属性就能达到我们想要的样式效果。 这篇文章目的在于记录开发中遇到的比较常见但又有些小窍门的一些布局技巧。 1. 父设置了overflow: hidden子如何不受影响123&lt;div style=\"width: 200px;height: 200px;padding:30px;margin: 30px auto;border: 1px solid #000;overflow: hidden;\"&gt; &lt;div style=\"width: 300px;height: 300px;background: #df3434;\"&gt;&lt;/div&gt;&lt;/div&gt; 给子元素一个position: absolute;定位即可 123&lt;div style=\"width: 200px;height: 200px;padding:30px;margin: 30px auto;border: 1px solid #000;overflow: hidden;\"&gt; &lt;div style=\"position:absolute;width: 300px;height: 300px;background: #df3434;\"&gt;&lt;/div&gt;&lt;/div&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"布局技巧","slug":"布局技巧","permalink":"/tags/布局技巧/"}]},{"title":"升级本地已安装的 Node 和 npm 版本","date":"2017-07-17T16:00:00.000Z","path":"node_npm_update/","text":"Mac升级本地已经安装的NodeJs和Npm到最新版,可以使用一下方式进行升级和更新。 其实windos上升级nodejs也很简单，只需在nodejs官网下载安装最新的msi即可。 值得注意的是安装时需要按原nodejs安装路径路径安装，不能安装到新的路径。 1. Node 版本升级step1： 查看本机当前 node 版本 1node -v step2： 清除nodejs的 cache 1npm cache clean -f step3： 安装node管理工具 n 这个工具是专门用来管理nodejs版本的，别怀疑这个工具的名字, 他的名字就是 &quot;n&quot; 1npm install -g n step4： 安装不同版本的 nodejs 1234567891011// 安装最新版本n latest// 安装稳定版本n stable// 安装或使用某一个版本n 8.2.0// 删除某个版本n rm 6.7.0 step5： 再次查看 node 版本 1node -v 2. 更新 npm 到最新版本1npm install npm@latest -g","tags":[{"name":"node","slug":"node","permalink":"/tags/node/"},{"name":"npm","slug":"npm","permalink":"/tags/npm/"}]},{"title":"Git 常用遇到的问题","date":"2017-07-11T16:00:00.000Z","path":"git_common_problem/","text":"开发中经常遇到一些奇奇怪怪的状况，以下是记录工作中遇到过的 Git 使用出现的问题，做以下记录 常遇到的问题1. git add ， git commit 添加错文件 撤销 git add 添加 多余文件 git status 先看一下add 中的文件git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了git reset HEAD xxx/xxx/xxx.js 就是对某个文件进行撤销了 git commit 错误 123git log // 查看节点 commit xxxxxxxxxxxxxxxxxxxxxxxxxx git reset commit_id 2. 撤销修改12git checkout . git checkout file 3. Git：refname’master’是不明确的warning: refname &#39;branch-name&#39; is ambiguous 1234$ git checkout RELEASEwarning: refname 'RELEASE' is ambiguous.Switched to branch 'RELEASE'Your branch is up to date with 'origin/RELEASE'. 解决方案 12git tag tag-master mastergit tag -d master 原文: Git：refname’master’是不明确的 4. HEAD detached at headHEAD 没有指到某个分支的時候，它会呈现 detached 状态。事实上，更正确的说，应该是「当 HEAD 没有指到某个『本地』的分支」就会呈现这种状态 12345678910111213$ git checkout origin/TESTNote: checking out 'origin/TEST'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b &lt;new-branch-name&gt;HEAD is now at e53d4cba update 12345$ git branch* (HEAD detached at origin/TEST) RELEASE dev_register_sqb master 要切换到远端分支而不呈现 detached HEAD 状态，可以加上 –track 或 -t 参数, -t 参数是指会在本地建立一个名为追踪分支（tracking branch）的东西 123456789$ git checkout -t origin/TESTBranch 'TEST' set up to track remote branch 'TEST' from 'origin'.Switched to a new branch 'TEST'$ git branch RELEASE* TEST dev_register_sqb master 参考文章:斷頭（detached HEAD）是怎麼一回事？如何从detached HEAD状态解救出来","tags":[{"name":"Git","slug":"Git","permalink":"/tags/Git/"}]},{"title":"Git 常用操作","date":"2017-07-10T16:00:00.000Z","path":"git_basis/","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 1. 安装和配置在使用Git前需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。 Git 各平台安装包下载地址为：http://git-scm.com/downloads 配置个人的用户名称和电子邮件地址: 12git config --global user.name \"undo\"git config --global user.email myundo@163.com 要检查已有的配置信息，可以使用 git config --list 命令： 12345git config --listuser.name=undouser.email=myundo@163.com... 2. Git 工作流程一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 3. Git 工作区、暂存区和版本库 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在”git目录”下的index文件中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 4. Git 基本操作4.1 创建仓库12345678// 在已有项目目录下git init// 指定仓库目录git init newrepo// 克隆项目并重新命名git clone [url] rename 4.2 工作流程大致流程使用如下 12345mkdir proDemocd proDemogit initgit add .git commit -m 'commit' git add 提交缓存，后面加 . 或者 -a， 表示全部缓存，也可以 git add file 提交文件， 多个文件用空格隔开 123git add .git add filegit add flieA fileB git commit 为本次提交添加备注, -m 选项在命令行中提供提交注释, 没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息. 1git commit -m 'commit' git add 和 git commit 可以合并为 1git commit -am 'commit' git reset HEAD 命令用于取消缓存已缓存的内容 12git reset HEAD // 撤销本次提交git reset HEAD -- hello.js // 撤销单个文件的提交 git rm 将文件从缓存区中移除,默认情况下,git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 如果要在工作目录中留着该文件，可以使用命令： 1git rm hello.js --cached 5. Git 分支管理查看分支 1git branch 新建分支 12git branch (branchname)git checkout -b (branchname) 切换分支 1git checkout (branchname) 删除分支 1git branch -d (branchname) 分支合并 1git merge (branchname) 合并冲突 12git merge testCONFLICT (content): Merge conflict in test.txt CONFLICT表示合并冲突就出现了,需要手动去修改它, 用 git add 告诉 Git 文件冲突已经解决, 然后继续 commit 查看提交历史 1git log 用 --oneline 选项来查看历史记录的简洁的版本, --graph 选项,查看历史中什么时候出现了分支、合并, 用 --reverse 参数来逆向显示所有日志, --author 查找指定用户的提交日志 指定日期: --since 和 --before，也可以用 --until 和 --after --no-merges 选项以隐藏合并提交 12345git log --onelinegit log --oneline --graphgit log --reverse --onelinegit log --author=Linus --onelinegit log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2017-06-18&#125; --no-merges 6. Git 管理远程分支查看远程连接 1git remote -v 参数可以看到每个别名的实际链接地址 添加远程连接 1git remote add [shortname] [url] shortname 添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用 提取远程仓库 git fetch 从远程仓库下载新分支与数据 1git fetch git pull 从远端仓库提取数据并尝试合并到当前分支, [shortname/branchname] 参数可以将指定连接的指定分支代码合并到当前分支 1git pull [shortname/branchname] git merge 加参数 shortname/branchname,也会合并远程分支到当前本地分支 1git merge [shortname/branchname] 推送到远程仓库 1git push [shortname] [branch] 删除远程仓库 1git remote rm [shortname] 删除远程分支和tag 12git push origin --delete &lt;branchName&gt;git push origin --delete tag &lt;tagname&gt; 否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支,删除tag的方法，推送一个空tag到远程tag 1234git push origin :&lt;branchName&gt;git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 删除不存在对应远程分支的本地分支 1git fetch -p 重命名远程分支 在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支 12345git push --delete origin develgit branch -m devel developgit branch -m devel develop 参考链接W3Cschool Git教程Git查看、删除、重命名远程分支和tag","tags":[{"name":"Git","slug":"Git","permalink":"/tags/Git/"}]},{"title":"原生JS实现jQuery中的DOM操作","date":"2017-06-24T16:00:00.000Z","path":"js_jQuery_dom/","text":"jQuery 是一个 “写的更少，但做的更多” 的轻量级 JavaScript 库. 基本上，学习到如何选取 HTML 元素,以及如何对它们执行类似隐藏、移动以及操作其内容等任务. 这篇文章用原生JS实现jQuery中大部分的DOM操作的方法. 为了方便判断浏览器兼容性, 用一下 flag 的值代表是否是 IE8以上浏览器 1var flag = 'getComputedStyle' in window; 1. win 操作浏览器盒子模型1234567891011//-&gt;win:一个有关于操作浏览器盒子模型的方法//如果只传递了attr没有传递value,默认的意思是“获取”//如果两个参数都传递了,意思是“设置”function win(attr, value) &#123; if (typeof value === 'undefined') &#123; return document.documentElement[attr] || document.body[attr]; &#125; document.documentElement[attr] = value; document.body[attr] = value;&#125; 2. offset 获取元素相对于body的偏移量1234567891011121314151617181920212223/** offset：Gets the offset of the current element distance BODY* @parameter：* curEle[object]：current element* @return：* [object]：&#123;top:xxx,left:xxx&#125;* By Team on 2017-04-23 16:43*/function offset(curEle) &#123; var par = curEle.offsetParent, totalLeft = curEle.offsetLeft, totalTop = curEle.offsetTop; while (par) &#123; if (navigator.userAgent.indexOf('MSIE 8.0') === -1) &#123; totalLeft += par.clientLeft; totalTop += par.clientTop; &#125; totalLeft += par.offsetLeft; totalTop += par.offsetTop; par = par.offsetParent; &#125; return &#123;left: totalLeft, top: totalTop&#125;&#125; offset: 等同于jQuery中的offset方法,实现获取页面中任意一个元素,距离body的偏移(包含左偏移和上偏移),不管当前元素的父级参照物是谁,获取的结果是一个对象 {left:距离BODY的左偏移,top:距离BODY的上偏移} 在标准的IE8浏览器中,使用offsetLeft/offsetTop其实是把父级参照物的边框已经算在内了,所以我们不需要自己在单独的加边框了 3. getCss 获取元素的style属性1234567891011121314151617181920212223242526272829/** getCss：Gets the value of the specific style property for the current element* @parameter：* curEle[object]：current element* attr[string]：style properties of elements* @return：* Style attribute values for elements* By Team on 2017-04-23 12:29*/function getCss(curEle, attr) &#123; var val = null, reg = null; if ('getComputedStyle' in window) &#123; val = window.getComputedStyle(curEle, null)[attr]; &#125; else &#123; //IE6~8 switch (attr) &#123; case 'filter': case 'opacity': val = curEle.currentStyle['filter']; //reg = /^alpha\\(opacity=(\\d+(?:\\.\\d+)?)\\)$/i; reg = /^alpha\\(opacity=(.+)\\)$/i; val = reg.test(val) ? RegExp.$1 / 100 : 1; break; default : val = curEle.currentStyle[attr]; &#125; &#125; reg = /^(?:-?\\d+(?:\\.\\d+)?)(?:px|pt|rem|em)?$/i; return reg.test(val) ? parseFloat(val) : val;&#125; 这是兼容写法, 新版浏览器支持getComputedStyle获取更方便, currentStyle 需要对透明度做特殊处理, 最后为了和jQuery保持一致去单位 4. setCss 为元素设置style属性123456789101112131415161718function setCss(curEle, attr, value) &#123; if (attr === 'opacity') &#123; curEle.style['opacity'] = value; curEle.style['filter'] = 'alpha(opacity=' + value * 100 + ')'; return; &#125; if (attr === 'float') &#123; curEle.style['cssFloat'] = value; curEle.style['styleFloat'] = value; return; &#125; //给部分样式属性做特殊处理,如果传递进来的样式属性值没有加单位,我们默认给补充px单位 var reg = /^(?:width|height|(?:(?:margin|padding)?(?:top|right|bottom|left)))$/i; if (reg.test(attr)) &#123; !isNaN(value) ? value += 'px' : null; &#125; curEle.style[attr] = value;&#125; 同样为了兼容各个浏览器需要对 opacity,float做特殊处理,需要对带单位的属性值添加单位 5. setGroupCss 为元素设置一组style12345678function setGroupCss(curEle, styleCollection) &#123; //循环传递进来的样式集合,调取SETCSS方法,给当前元素逐一设置样式即可 for (var key in styleCollection) &#123; if (styleCollection.hasOwnProperty(key)) &#123; setCss(curEle, key, styleCollection[key]); &#125; &#125;&#125; 6. css12345678910function css(curEle) &#123; if (arguments.length &gt;= 3) &#123; setCss.apply(this, arguments); return; &#125; if (arguments.length === 2 &amp;&amp; typeof arguments[1] === 'object') &#123; setGroupCss.apply(this, arguments); &#125; return getCss.apply(this, arguments);&#125; 将 getCss setCss setGroupCss 整合 , 达到jQuery中css相同的效果 7. children 获取元素的子元素1234567891011121314151617181920212223function children(curEle, tagName) &#123; var ary = []; if (!flag) &#123; var nodeList = curEle.childNodes; for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; var curNode = arguments[i]; curNode.nodeType === 1 ? ary[ary.length] = curNode : null; &#125; nodeList = null; &#125; else &#123; ary = Array.prototype.slice.call(curEle.children); &#125; if (typeof tagName === 'string') &#123; for (var j = 0; j &lt; ary.length; j++) &#123; var curEleNode = ary[j]; if (curEleNode.nodeName !== tagName.toUpperCase()) &#123; ary.splice(j, 1); j--; &#125; &#125; &#125; return ary;&#125; 8. prev 获取元素的上一个哥哥元素123456789101112131415161718/** prev：获取当前元素的上一个哥哥元素节点(兼容所有浏览器)* @parameter* curEle:current element 当前操作的元素* @return* 上一个哥哥元素节点或者是null(没有返回null)* By Team on 2017-04-08 11:18*/function prev(curEle) &#123; if (flag) &#123; return curEle.previousElementSibling; &#125; var pre = curEle.previousSibling; if (pre &amp;&amp; pre.nodeType !== 1) &#123; pre = pre.previousSibling; &#125; return pre;&#125; 9. prevAll 获取元素的所有哥哥元素12345678910111213141516 /** prevAll：获取当前元素的所有哥哥元素节点(兼容所有浏览器)* @parameter* curEle:current element 当前操作的元素* @return* 所有的哥哥元素节点或者是null(没有返回null)* By Team on 2017-04-08 11:18*/function prevAll(curEle) &#123; var ary = [], pre = prev(curEle); while (pre) &#123; ary.push(pre); pre = prev(pre); &#125; return ary;&#125; 10. next 获取元素的下一个弟弟元素123456789101112131415161718/** next：获取当前元素的下一个弟弟元素节点(兼容所有浏览器)* @parameter* curEle:current element 当前操作的元素* @return* 下一个弟弟元素节点或者是null(没有返回null)* By Team on 2017-04-08 11:18*/function next(curEle) &#123; if (flag) &#123; return curEle.nextElementSibling; &#125; var nex = curEle.nextSibling; if (nex &amp;&amp; nex.nodeType !== 1) &#123; nex = nex.nextSibling; &#125; return nex;&#125; 11. nextAll 获取元素的所有弟弟元素12345678910111213141516/** nextAll：获取当前元素的所有弟弟元素节点(兼容所有浏览器)* @parameter* curEle:current element 当前操作的元素* @return* 所有的弟弟元素节点或者是null(没有返回null)* By Team on 2017-04-08 11:18*/function nextAll(curEle) &#123; var ary = [], nex = next(curEle); while (nex) &#123; ary.push(nex); nex = next(nex); &#125; return ary;&#125; 12. sibling 获取元素相邻元素12345678function sibling(curEle) &#123; var pre = prev(curEle); var nex = next(curEle); var ary = []; pre ? ary.push(pre) : null; nex ? ary.push(nex) : null; return ary;&#125; 13. siblings 获取元素的所有兄弟元素123function siblings(curEle) &#123; return this.prevAll(curEle).concat(nextAll(curEle));&#125; 14. index 获取元素所在的索引123function index(curEle) &#123; return prevAll(curEle).length;&#125; 15. firstChild 获取第一个子节点1234function firstChild(curEle) &#123; var chs = children(curEle); return chs.length &gt; 0 ? chs[0] : null;&#125; 16. lastChild 获取最后一个子节点1234function lastChild(curEle) &#123; var chs = children(curEle); return chs.length &gt; 0 ? chs[chs.length - 1] : null; &#125; 17. append 向指定容器的末尾追加元素123function append(newEle, container) &#123; container.appendChild(newEle);&#125; 18. prepend 向指定容器的开头追加元素把新的元素添加到容器中第一个子元素节点的前面,如果一个元素子节点都没有,就放在末尾即可 12345678function prepend(newEle, container) &#123; var fir = firstChild(container); if (fir) &#123; container.insertBefore(newEle, fir); return; &#125; container.appendChild(curEle);&#125; 19. insertBefore 把新元素追加到指定元素的前面123function insertBefore(newEle, oldEle) &#123; oldEle.parentNode.insertBefore(newEle, oldEle);&#125; 20. insertAfter 把新元素追加到指定元素的后面相当于追加到oldEle弟弟元素的前面,如果弟弟不存在,也就是当前元素已经是最后一个了,我们把新的元素放在最末尾即可 12345678 function insertAfter(newEle, oldEle) &#123; var nex = next(oldEle); if (nex) &#123; oldEle.parentNode.insertBefore(newEle, nex); return; &#125; oldEle.parentNode.appendChild(newEle);&#125; 21. hasClass 判断元素是否有某个class123function hasClass(curEle, cName) &#123; return new RegExp('\\\\b' + cName + '\\\\b').test(curEle.className);&#125; 22. addClass 为元素添加class123456789function addClass(curEle, strClass) &#123; strClass = strClass.replace(/(^ +| +$)/g, \"\").split(/ +/g); for (var i = 0, len = strClass.length; i &lt; len; i++) &#123; var curClass = strClass[i]; if (!hasClass(curEle, curClass)) &#123; curEle.className += \" \" + curClass; &#125; &#125;&#125; 23. removeClass 移除元素中的class123456789function removeClass(curEle, strClass) &#123; strClass = strClass.replace(/(^ +| +$)/g, \"\").split(/ +/g); for (var i = 0, len = strClass.length; i &lt; len; i++) &#123; var curClass = strClass[i]; var reg = new RegExp(\"(^| +)\" + curClass + \"( +|$)\", \"g\"); hasClass(curEle, curClass) ? curEle.className = curEle.className.replace(/ /g,' ').replace(reg, \" \") : null; curEle.className = curEle.className.replace(/(^ +| +$)/, \" \"); &#125;&#125; 24. toggleClass 切换元素的class1234567function toggleClass(curEle, strClass) &#123; strClass = strClass.replace(/(^ +| +$)/g, \"\").split(/ +/g); for (var i = 0; i &lt; strClass.length; i++) &#123; var curClass = strClass[i]; hasClass(curEle, curClass) ? removeClass(curEle, curClass) : addClass(curEle, curClass); &#125;&#125; 25. getElementsByClass1234567891011121314function getElementsByClass(strClass, context) &#123; context = context || document; if (flag) &#123; return listToArray(context.getElementsByClassName(strClass)); &#125; strClass = strClass.replace(/(^ +| +$)/g, '').replace(/ +/g, '@@').replace(/(?:^|@)([\\w-]+)(?:@|$)/g, '(?=.*(^| +)$1( +|$).*)'); var ary = [], reg = new RegExp(strClass), nodeList = context.getElementsByTagName('*'); for (var i = 0; i &lt; nodeList.length; i++) &#123; var curNode = nodeList[i]; reg.test(curNode.className) ? ary[ary.length] = curNode : null; &#125; return ary;&#125; 正则的方式比较简单,但是正则不容易写出来,还有其他的方式 1234567891011121314151617181920212223function getElementsByClass(strClass, context) &#123; context = context || document; if ('getComputedStyle' in window) &#123; return [].slice.call(context.getElementsByClassName(strClass)); &#125; var ary = [], strClassAry = strClass.replace(/(^ +| +$)/g, '').split(/ +/g); var nodeList = context.getElementsByTagName('*'); for (var i = 0; i &lt; nodeList.length; i++) &#123; var curNode = nodeList[i]; var isTrue = true; for (var j = 0; j &lt; strClassAry.length; j++) &#123; var curName = strClassAry[j]; if (!hasClass(curNode, curName)) &#123; isTrue = false; break; &#125; &#125; if (isTrue) &#123; ary.push(curNode); &#125; &#125; return ary;&#125; 总结以上实现了大部分的常用的DOM操作的兼容写法,目的不在于去实现jQuery中API,而是从原理上理解jQuery API的实现原理,锻炼个人的编程能力,升华编程思想.","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"jQuery","slug":"jQuery","permalink":"/tags/jQuery/"},{"name":"DOM操作","slug":"DOM操作","permalink":"/tags/DOM操作/"}]},{"title":"面向对象原型链和原型链查找机制","date":"2017-06-22T16:00:00.000Z","path":"js_archetypal_chain/","text":"原型链相关知识在找工作面试中很高概率会被问到,以及面向对象,继承等相关知识.本文以之前面试中被问到的两个典型面试题来理解原型链. 面试题 112345function Fn() &#123;&#125;let f = new Fn()// 填空题 填入适当的值使以下等式成立f._________ === Fn.___________ 面试题 212345Function.prototype.a = 1Object.prototype.b = 2function Fn() &#123;&#125;let f = new Fn()console.log(f.a, f.b) 这两道题并不难,但是很考验基本功掌握的扎实程度,要能完全答对需要搞清楚原型链的相关知识,搞清楚 Object, Function, prototype, __proto__之间的关系. 先来了解一下基本概念. 1. 基本概念1.1 原型 prototype每个函数都有一个属性 prototype, 它是一个对象,它有最基本的两个属性 constructor 指向函数本身 12345function Fn() &#123;&#125;Fn.prototype = &#123; constructor: Fn, ...&#125; 一般情况下prototype都是 object 类型的, 但有一个例外 Function.prototype 是 function 类型的 1234function Fn() &#123;&#125;console.dir(Fn)console.log(typeof Function.prototype) // functionconsole.log(typeof Fn.prototype) // object 1.2 __proto__每一个对象数据类型(普通的对象、实例、prototype等)也都有一个属性：__proto__，属性值是当前对象所属类的原型 那么到这里,第一道面试题的答案也就明了了, f 是 Fn的实例,是一个普通对象object类型,那么它的__proto__指向的是Fn,prototype 所以答案就是 f.__proto__ === Fn.prototype 1234function Fn() &#123;&#125;let f = new Fn()console.log(typeof f) // objectconsole.log(f.__proto__ === Fn.prototype) // true 但是,在Object.prototype上没有__proto__这个属性, 因为 Object是JS中所有对象数据类型的基类,位于原型链的最顶端 那么第二题的解法也是根据 prototype 和 __proto__ 来进行查找的, 这里先了解一下原型链的查找机制 2. 原型链查找机制 通过 对象名.属性名 的方式获取属性值的时候,首先在对象的私有的属性上进行查找,如果私有中存在这个属性,则获取的是私有的属性值. 如果私有的没有,则通过 __proto__ 找到所属类的原型(类的原型上定义的属性和方法都是当前实例公有的属性和方法),原型上存在的话,获取的是公有的属性值 如果原型上也没有,则继续通过原型上的 __proto__ 继续向上查找,一直找到 Object.prototype 为止… 这就是 原型链查找机制 第二题中f.a , f.b,首先我们会在f的私有属性上找这两个属性,则根据 原型链查找机制 继续向上找,最终在 Object 的原型上找到 b,而没找到 a,所以答案是 undefined 2 那么怎么取到 a 呢 , Fn.a 则可以根据 原型链查找机制 在 Function 的原型上找到 来看下面这张图,大致了解一下JS世界中所有数据类型的原型关系 总结一下原型链,原型链查找 并不难, 掌握一下几条法则即可轻松搞定 每一个函数数据类型(普通函数、类)都有自带的属性:prototype,并且这个属性是一个对象数据类型的值,指向原型 每一个对象数据类型的值都有 __proto__ 属性,指向该对象所属类的原型 原型链查找机制 进行 对象名.属性名 取值 每一个函数 都是 Function 的实例, 所以 函数 也有 __proto__ 属性,指向 Function.prototype 有意思的是 Object.__proto__ 指向的是 Function.prototype, 而 Function.prototype.__proto__ 指向了 Object.prototype, Function.__proto__ 也指向了 Function.prototype 123console.log(Object.__proto__ === Function.prototype) // trueconsole.log(Function.prototype.__proto__ === Object.prototype) // trueconsole.log(Function.prototype === Function.__proto__) // true","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"原型链","slug":"原型链","permalink":"/tags/原型链/"}]},{"title":"JavaScript中的继承","date":"2017-06-22T16:00:00.000Z","path":"js_inherit/","text":"继承 是面向对象语言的重要概念, 许多面向对象编程语言都支持两种继承方式: 接口继承和实现继承. 接口继承只继承方法签名, 而实现继承则继承实际的方法. JavaScript 中所有的类其实都是函数, 而函数没有签名, 则无法实现接口继承, 只支持实现继承, 而且实现继承主要是依据原型链来实现的. JavaScript 中实现继承的方式有很多种, 但都是依赖于原型链,也正是原型链使得整个 JavaScript 世界连接在了一起. 下面来具体看看几种常用的继承是如何实现的. 1. 原型继承原型继承是JS中最常用的一种继承方式, 子类B想要继承父类A中的所有的属性和方法(私有+公有),只需要让 B.prototype=new A即可 原型继承的特点：它是把父类中私有的+公有的 都继承到了子类原型上(子类公有的) 1234567891011121314function A() &#123; this.x = 100;&#125;A.prototype.getX = function () &#123; console.log(this.x);&#125;;function B() &#123; this.x = 200;&#125;B.prototype = new A;B.prototype.constructor = B; constructor 是类的原型上很重要的属性, 原型继承方式是重写 B.prototype 因此需要手动将 B.prototype.constructor 指向 B 核心：原型继承并不是把父类中的属性和方法克隆一份一模一样的给B, 而是让B和A之间增加了原型链的连接, B的实例想要访问和使用A中的getX方法,需要根据 原型链查找机制 进行查找使用 2. call继承call继承：把父类私有的属性和方法 克隆一份 一模一样的 作为子类私有的属性 1234567891011121314function A() &#123; this.x = 100;&#125;A.prototype.getX = function () &#123; console.log(this.x);&#125;;function B() &#123; A.call(this); // A.call(n) 把A执行让A中的this变为了n&#125;var n = new B;console.log(n.x); // 100console.log(n.getX); // undefined 这种继承方式只是继承了父类中的私有属性给子类的私有属性,父类原型上的公有属性将无法被继承. 3. 冒充对象继承冒充对象继承：把父类私有的 + 公有的属性 克隆一份一模一样的 给子类私有的 1234567891011121314151617function A() &#123; this.x = 100;&#125;A.prototype.getX = function () &#123; console.log(this.x);&#125;;function B() &#123; var temp = new A; for (var key in temp) &#123; this[key] = temp[key]; &#125; temp = null;&#125;var n = new B;n.getX(); // 100 4. 组合模式继承组合模式继承: 原型继承+call继承 混合使用, 将父类的私有属性继承给子类的私有属性, 将父类的实例赋值给子类父类原型. 1234567891011121314151617function A() &#123; this.x = 100;&#125;A.prototype.getX = function () &#123; console.log(this.x);&#125;;function B() &#123; A.call(this); this.y = 200;&#125;B.prototype = new A;B.prototype.constructor = B;var n = new B;n.getX(); // 100console.log(n.y); // 200 这种继承方式避免了 原型继承 和 call继承 的缺陷, 融合了他们的优点, 成为 JavaScript 中最常用的继承模式. 5. 寄生组合式继承寄生组合式继承: 将父类私有熟悉继承给子类私有,将父类公有继承给子类公有. 123456789101112131415161718192021222324function A() &#123; this.x = 100;&#125;A.prototype.getX = function () &#123; console.log(this.x);&#125;;function B() &#123; A.call(this);&#125;B.prototype = objectCreate(A.prototype);B.prototype.constructor = B;var n = new B;console.dir(n);//-&gt;Object.create(proObj) 创建一个新的对象,但是还要把proObj作为这个对象的原型 在IE6~8不兼容(ECMAScript5)function objectCreate(o) &#123; function fn() &#123; &#125; fn.prototype = o; return new fn;&#125; 总结以上就是 JavaScript 中比较常见的几种继承, 实际运用中根据场景需要合理使用, 充分利用各种继承方式的特点.","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"面向对象","slug":"面向对象","permalink":"/tags/面向对象/"},{"name":"继承","slug":"继承","permalink":"/tags/继承/"}]},{"title":"面向对象基础和创建对象的几种模式","date":"2017-06-21T16:00:00.000Z","path":"js_pattern/","text":"面向对象是一种编程思想,很多编程语言都基于这种思想. 面向对象的语言有一个标志,那就是他们都有类的概念,而通过类可以创建任意多个具有相同属性和方法的对象. ECMAScript 中没有类的概念,它把对象定义为 “无序属性的集合,器属性可以包含基本值,对象或者函数”, 对象的每个属性或方法都有一个名字,每个名字有映射一个值, 因此ECMAScript中的对象无非就是一组名值对, 值可以是任意数据. 1. 理解对象JavaScript 中的所有事物都是对象:字符串、数值、数组、函数… 对象只是带有属性和方法的特殊数据类型。 JavaScript 提供多个内建对象,比如 String、Date、Array 等等. 创建对象常用的方式有两种, 构造函数和字面量,下面两种方式可以达到相同的效果 12345678910// 构造函数方式创建对象var p = new Object()p.name = 'undo'p.age = 26// 字面量方式创建对象var p = &#123; name: 'undo', age: 26&#125; 2. 几种创建对象的模式2.1 单例模式单例模式是项目开发中经常使用的模式,因为项目中我们可以使用单例模式来进行我们的”模块化开发” 模块化开发:对于一个相对来说比较大的项目,需要多人协作的开发的,我们一般情况下会根据当前项目的需求划分成几个功能版块,每个人负责一部分,同时开发,最后把每个人的代码进行合并 单例模式 其实就是字面量的方式创建对象,把描述同一个事物(同一个对象)的属性和方法放在一个内存空间下,起到了分组的作用,这样不同事物之间的属性即使属性名相同,相互也不会发生冲突, 把这种分组编写代码的模式叫做&quot;单例模式&quot; 123456789var person1 = &#123; name: \"Jack\", age: 18&#125;var person2 = &#123; name: \"John\", age: 48&#125; 在单例模式中我们把person1,person2也叫做 &quot;命名空间&quot; 单例模式 开发中需要开辟多个命名空间,即使不同命名空间之间有相同或相似的地方也需要在各自的命名空间内再写一遍,没有封装的概念,并非面向对象编程. 单例模式虽然解决了分组的作用,但是不能实现批量的生产,属于手工作业模式, 工厂模式 应运而生 2.2 工厂模式工厂模式 抽象了创建具体对象的过程,用函数来封装特定接口创建对象. 1234567891011121314function createPerson(name, age) &#123; var obj = &#123;&#125;; obj.name = name; obj.age = age; obj.writeJs = function () &#123; console.log(\"my name is \" + this.name + \",i can write js 啦~~\"); &#125;; return obj;&#125;var p1 = createPerson(\"王小波\", 48);p1.writeJs();var p2 = createPerson(\"尹华芝\", 18);p2.writeJs(); 可以无限次的调用 createPerson 函数,每次它都会返回一个包含两个属性一个方法的对象. 工厂模式 虽然解决了创建多个相似对象的问题,但却没有解决对象识别的问题(即怎么知道一个对象的类型),于是有了新的模式. 2.3 构造函数模式构造函数 可用来创建特定类型的对象, 像 Object 和 Array这样的原生构造函数, 它不再是以具体事物为研究对象,而是以一类事物为研究对象. 12345678910111213141516function CreatePerson(name, age) &#123; this.name = name; this.age = age; this.writeJs = function () &#123; console.log(\"my name is \" + this.name + \",i can write js 啦!!\"); &#125;;&#125;var p1 = new CreatePerson(\"尹华芝\", 18); // CreateJsPerson-&gt;this p1p1.writeJs(); // writeJs-&gt;this p1var p2 = new CreatePerson(\"王小波\", 25); // CreateJsPerson-&gt;this p2p2.writeJs(); // writeJs-&gt;this p2var res = CreateJsPerson(\"王小波\", 7);// 这样写不是构造函数模式执行而是普通的函数执行 由于没有写return所以res=undefined 并且CreateJsPerson这个方法中的this是windowconsole.log(res); // undefined 构造函数 创建对象的原理 123456function create(name, age) &#123; var obj = &#123;&#125; obj.__proto__ = CreatePerson.prototype var result = CreatePerson.call(obj,name, age) return typeof result === 'obj' ? result : obj&#125; 函数的三种角色 普通函数: 像普通函数一样执行 普通对象: 可以用 函数名.属性名 的方式添加或访问函数的静态方法 构造函数: 使用 new 关键字操作符, 以构造函数方式运行 这三种角色灵活运用开发效率将大大提高,jQuery 就很巧妙的利用了函数的这一特性 构造函数模式和工厂模式的区别? 1、执行的时候 普通函数执行-&gt;createPerson()构造函数模式-&gt;new CreatePerson() 通过new执行后,我们的CreateJsPerson就是一个类了而函数执行的返回值(p1)就是CreateJsPerson这个类的一个实例 2、在函数代码执行的时候 相同:都是形成一个私有的作用域,然后 形参赋值-&gt;预解释-&gt;代码从上到下执行 (类和普通函数一样,它也有普通的一面)不同:在代码执行之前,不用自己在手动的创建obj对象了,浏览器会默认的创建一个对象数据类型的值(这个对象其实就是我们当前类的一个实例)接下来代码从上到下执行，以当前的实例为执行的主体(this代表的就是当前的实例),然后分别的把属性名和属性值赋值给当前的实例最后浏览器会默认的把创建的实例返回 构造函数模式 虽然好用,但也有缺点,就是每个方法都需要在每个实例上创建一遍,而且他们指向了不同的内存空间. 1console.log(p1.writeJs === p2.writeJs) // false 创建两个完全相同任务的 Function 实例是没有必要的, 我们可以把 writeJs() 函数定义到构造函数外部,然后构造函数内 this.writeJs = writeJs 123456789function CreatePerson(name, age) &#123; this.name = name; this.age = age; this.writeJs = writeJs&#125;function writeJs() &#123; console.log(\"my name is \" + this.name + \",i can write js 啦!!\");&#125; 但是这么做有另外的问题: 1. 在全局定义的函数实际上只能被某个对象调用,全局作用域有点名不副实. 2. 如果需要定义很多方法,那么需要定义很多的全局方法,那么这个自定义类就丝毫没有封装性可言了. 这些问题可以通过原型模式来解决. 2.4 原型模式构造函数模式中拥有了类和实例的概念,并且实例和实例之间是相互独立开的 基于构造函数模式的原型模式解决了方法或者属性公有的问题,即把实例之间相同的属性和方法提取成公有的属性和方法 ,把它们放在构造函数的 prototype上即可 123456789101112function CreatePerson(name, age) &#123; this.name = name; this.age = age;&#125;CreatePerson.prototype.writeJs = function() &#123; console.log(\"my name is \" + this.name + \",i can write js 啦!!\");&#125;CreatePerson.prototype.sayAge = function() &#123; console.log(\"I'am \" + this.age + \"years old !\");&#125; 这样 name,age是每个实例对象的私有属性, 而 writeJs, sayAge 是所有 CreatePerson 的实例的公有方法, 而且指向了同一内存空间 如果觉得在原型上一个个添加属性比较麻烦,可以让构造函数的原型指向一个对象, 但是对象中需要手动添加constructor 属性,并且指向构造函数本身 12345678910111213function CreatePerson(name, age) &#123; this.name = name; this.age = age;&#125;CreatePerson.prototyp = &#123; writeJs: function() &#123; console.log(\"my name is \" + this.name + \",i can write js 啦!!\"); &#125;, sayAge: function() &#123; console.log(\"I'am \" + this.age + \"years old !\"); &#125;&#125; 每创建一个函数,会用时创建它的prototype对象, 这个对象会自动获得constructor属性指向函数本身. 以上写法重写了默认的prototype 对象,因此constructor 属性不再指向CreatePerson, 而是指向Object. 123456var p = new CreatePerson('undo', 26)console.log(p instanceof CreatePerson) // falseconsole.log(p instanceof Object) // trueconsole.log(p.constructor == CreatePerson) // falseconsole.logp.constructor == Object) // true constructor 属性很重要,可以根据它的值确定对象的类型,所以需要手动添加. 123456789CreatePerson.prototyp = &#123; constructor: CreatePerson, writeJs: function() &#123; console.log(\"my name is \" + this.name + \",i can write js 啦!!\"); &#125;, sayAge: function() &#123; console.log(\"I'am \" + this.age + \"years old !\"); &#125;&#125; hasOwnProperty() 可以区分属性是实例属性还是原型属性. 12console.log(p.hasOwnProperty('name')) // trueconsole.log(p.hasOwnProperty('sayAge')) // false in 操作符, 会在通过对象能够访问给定属性时返回true,不区分实例属性和原型属性12console.log('name' in p) // trueconsole.log('sayAge' in p) // true 使用for-in遍历对象的实例属性,可以使用下面的方法进行过滤 123function hasPrototypeProperty(object, name) &#123; return !object.hasOwnProperty(name) &amp;&amp; (name in object)&#125; Object.keys() 返回一个包含所有可枚举实例属性的字符串数组 12var keys = Object.keys(p)console.log(keys) // ['name', 'age'] Object.getOwnPropertyNames() 返回所有的实例属性无论是否可以枚举 12var keys = Object.getOwnPropertyNames(p.prototype)console.log(keys) // ['constructor', 'writeJs', 'sayAge']","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"面向对象","slug":"面向对象","permalink":"/tags/面向对象/"},{"name":"构造函数","slug":"构造函数","permalink":"/tags/构造函数/"}]},{"title":"手动实现数组的slice方法","date":"2017-06-20T16:00:00.000Z","path":"js_array_slice/","text":"数组是我们开发中最常用的数据类型之一,有强大的API接口和功能供我们使用. 找工作面试的时候难免会问一些API的实现原理或者手写某个API,下面记录一下我自己实现的数组的 slice 方法 1. 准备工作slice([begin],[end]) 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改。 要实现这个API,首先得充分使用它,了解它的工作原理,输入什么,输出什么. slice 方法的参数情况比较复杂,有很多种,需要尝试各种传参方式,看输出结果,总结参数的处理规律. 一番尝试之后发现,其实实现这个 API 主要在于参数的处理,对各种可能的参数进行兼容处理,就基本能够实现它 参数解读 begin [可选] 从该索引处开始提取原数组中的元素（从0开始）。 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。 如果省略 begin，则 slice 从索引 0 开始。 end [可选] 在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。 slice(1,4) 提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。 如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果end 被省略，则slice 会一直提取到原数组末尾。 如果 end 大于数组长度，slice 也会一直提取到原数组末尾。 2. 着手实现在数组的原型上添加我自己实现的 mySlice 方法 12345678910Array.prototype.mySlice = function mySlice(begin, end) &#123; var ary = [], _end = typeof end === \"undefined\" ? this.length : end; var n = Number(begin) || 0, m = Number(_end) || 0; n = n &lt; 0 ? ((n + this.length) &lt; 0 ? 0 : Math.ceil(n + this.length)) : Math.floor(n); m = m &lt; 0 ? Math.ceil(m + this.length) : (m &lt;= this.length ? Math.floor(m) : this.length); for (var i = n; i &lt; m; i++) &#123; ary[ary.length] = this[i]; &#125; return ary;&#125;; 以上是按照传参的规律进行实现的 mySlice 方法,包括处理 传递非数字参数,小数参数等情况 可以测试一下,与原 slice 方法做下对比, 遇到没处理好的参数情况再进行优化. 我的测试用例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124var ary = [23, 14, 5, 6, 56, 78, 32, 11];console.log(\"mySlice: \", ary.mySlice(1, 4));console.log(\"slice: \", ary.mySlice(1, 4));console.log(ary.slice(&#123;&#125;));console.log(ary.mySlice(&#123;&#125;));console.log(ary.slice(-(ary.length + 1)));console.log(ary.mySlice(-(ary.length + 1)));console.log(ary.slice(-1));console.log(ary.mySlice(-1));console.log(ary.slice(-1.2));console.log(ary.mySlice(-1.2));console.log(ary.slice(ary.length));console.log(ary.mySlice(ary.length));console.log(ary.slice(3));console.log(ary.mySlice(3));console.log(ary.slice(3.2));console.log(ary.mySlice(3.2));console.log(ary.slice(undefined));console.log(ary.mySlice(undefined));console.log(ary.slice(3, 1));console.log(ary.mySlice(3, 1));console.log(ary.slice(33, 111));console.log(ary.mySlice(33, 111));console.log(ary.slice(-333, -111));console.log(ary.mySlice(-333, -111));console.log(ary.slice(-12, -2));console.log(ary.mySlice(-12, -2));console.log(ary.slice(-12, 3));console.log(ary.mySlice(-12, 3));console.log(ary.slice(-12, 13));console.log(ary.mySlice(-12, 13));console.log(ary.slice(-9, -5));console.log(ary.mySlice(-9, -5));console.log(ary.slice(-1, 2));console.log(ary.mySlice(-1, 2));console.log(ary.slice(-5, 7));console.log(ary.mySlice(-5, 7));console.log(ary.slice(-5, 17));console.log(ary.mySlice(-5, 17));console.log(ary.slice(2, 5));console.log(ary.mySlice(2, 5));console.log(ary.slice(3, 18));console.log(ary.mySlice(3, 18));console.log(ary.slice(NaN, -11));console.log(ary.mySlice(NaN, -11));console.log(ary.slice(NaN, -5));console.log(ary.mySlice(NaN, -5));console.log(ary.slice(NaN, 11));console.log(ary.mySlice(NaN, 11));console.log(ary.slice(NaN, 5));console.log(ary.mySlice(NaN, 5));console.log(ary.slice(5, NaN));console.log(ary.mySlice(5, NaN));console.log(ary.slice(undefined, NaN));console.log(ary.mySlice(undefined, NaN));console.log(ary.slice(undefined, -111));console.log(ary.mySlice(undefined, -111));console.log(ary.slice(undefined, -3));console.log(ary.mySlice(undefined, -3));console.log(ary.slice(undefined, 0));console.log(ary.mySlice(undefined, 0));console.log(ary.slice(undefined,5));console.log(ary.mySlice(undefined, 5));console.log(ary.slice(undefined, 111));console.log(ary.mySlice(undefined, 111));console.log(ary.slice(undefined, null));console.log(ary.mySlice(undefined, null));console.log(ary.slice(NaN, undefined));console.log(ary.mySlice(NaN, undefined));console.log(ary.slice(-111, undefined));console.log(ary.mySlice(-111, undefined));console.log(ary.slice(-3, undefined));console.log(ary.mySlice(-3, undefined));console.log(ary.slice(0, undefined));console.log(ary.mySlice(0, undefined));console.log(ary.slice(2, undefined));console.log(ary.mySlice(2, undefined));console.log(ary.slice(111, undefined));console.log(ary.mySlice(111, undefined));console.log(ary.slice(null, undefined));console.log(ary.mySlice(null, undefined));console.log(ary.slice(undefined, undefined));console.log(ary.mySlice(undefined, undefined));","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"slice","slug":"slice","permalink":"/tags/slice/"},{"name":"Array","slug":"Array","permalink":"/tags/Array/"}]},{"title":"JS中检测数据类型的几种方式","date":"2017-06-19T16:00:00.000Z","path":"js_detection_data_type/","text":"JS中检测数据类型的方式有多种,各种方式都有它的特点和局限性,在使用的时候可以根据业务场景进行合理的选择. 常用的方式有 typeof , instanceof , constructor , Object.prototype.toString 1. typeof检测基本数据类型, 返回的是 &quot;number&quot;, &quot;string&quot;, &quot;boolean&quot;, &quot;undefined&quot;, &quot;object&quot;, &quot;function&quot;表示这些数据类型的&quot;字符串&quot; 局限性： 没办法检测复杂的引用数据类型的具体数据类型,typeof null 得到的是 &quot;object&quot;对于引用数据类型的返回值：1234console.log(typeof []) // \"object\"console.log(typeof &#123;&#125;) // \"object\"console.log(typeof /$/) // \"object\"console.log(typeof isNaN) // \"function\" 规律： 多个typeof连续使用的时候返回的都是&quot;string&quot;1console.log(typeof(typeof(typeof(typeof [])))) \"string\" 2. instanceof语法： [] instanceof Array 返回 true or falseinstanceof 用来检测&quot;引用类型&quot;的具体数据类型，判断实例是否属于某个类,不能判断&quot;字面量方式申明的&quot;基本数据类型但是可以检测实例方式创建的基本数据类型的值，如下：1234var c = new String('qwe');console.log(c instanceof String) // truevar num = new Number(12);console.log(num instanceof Number) // true 由于原型链查找机制,会导致检测不准确,或者说不是想要的结果123var c = new String('qwe');console.log(c instanceof Object) // trueconsole.log(c instanceof String) // true 3. constructorconstructor 检测目标对象是否是某个类的构造类,除了不能检测null和undefined，其他的都能检测语法： 实例.constructor === 构造函数 返回 true or false123console.log([].constructor === Array) // trueconsole.log('2'.constructor === Array) // falseconsole.log('2'.constructor === String) // true null 和 undefined 不能使用 constructor 来检测,语法上直接会报错在自定义类中如果重写了原型,而没有将constructor重新指回该类的话,使用这种方式检测也会出现问题. 4. Object.prototype.toString以上三种方式都是有缺陷的,不能适用于所有的数据类型或者检测结果不准确,但是 这种方式能够满足准确检测所有的数据类型 语法: Object.prototype.toString.call([]); 返回字符串 &quot;[object Array]&quot; 123456console.log(Object.prototype.toString.call([])); // \"[object Array]\"console.log(Object.prototype.toString.call(&#123;&#125;)); // \"[object Object]\"console.log(Object.prototype.toString.call('www')); // \"[object String]\"console.log(Object.prototype.toString.call(null)); // \"[object Null]\"console.log(Object.prototype.toString.call(undefined)); // \"[object Undefined]\"console.log(Object.prototype.toString.call(console.log)); // \"[object Function]\"","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"JS基础","slug":"JS基础","permalink":"/tags/JS基础/"},{"name":"检测数据类型","slug":"检测数据类型","permalink":"/tags/检测数据类型/"}]},{"title":"JS中常见的几种排序算法","date":"2017-06-19T16:00:00.000Z","path":"js_sorting_algorithm/","text":"JS中常见的排序算法有很多,这里简单介绍几种最常见的三种排序算法: 冒泡排序, 快速排序, 插入排序 以下排序算法的实现都是基于数组的, 且都是数字. 1. 冒泡排序冒泡排序 是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止.它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1234567891011121314151617181920function bubbleSort(ary) &#123; var len = ary.length, flag = null; if (len &gt; 1) &#123; for (var i = 0; i &lt; len - 1; i++) &#123; flag = false; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (ary[j] &gt; ary[j + 1]) &#123; var temp = ary[j]; ary[j] = ary[j + 1]; ary[j + 1] = temp; flag = true; &#125; &#125; if (!flag) &#123; break; &#125; &#125; &#125; return ary;&#125; 算法中利用 flag 进行排序次数的优化, 如果本轮中出现当前项不大于后一项的时候说明本轮排序已经结束. 时间复杂度最佳情况：T(n) = O(n)最差情况：T(n) = O(n^2)平均情况：T(n) = O(n^2) 2. 快速排序 在数据集之中，选择一个元素作为”基准”（pivot）。 所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。 对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 123456789101112function quickSort(ary) &#123; var len = ary.length; if (len &lt;= 1) &#123; return ary; &#125; var leftArr = [], rightArr = [], tar = ary[0]; for (var i = 1; i &lt; len; i++) &#123; var cur = ary[i]; cur &lt; tar ? leftArr.push(cur) : rightArr.push(cur); &#125; return quickSort(leftArr).concat(tar, quickSort(rightArr));&#125; 时间复杂度 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n^2)平均情况：T(n) = O(nlogn) 3. 插入排序插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 12345678910111213141516function inertSort(ary) &#123; var len = ary.length; if (len &gt; 1) &#123; for (var i = 1; i &lt; len; i++) &#123; if (ary[i] &lt; ary[i - 1]) &#123; var cur = ary[i], j = i - 1; while (j &gt;= 0 &amp;&amp; cur &lt; ary[j]) &#123; ary[j + 1] = ary[j]; j--; &#125; ary[j + 1] = cur; &#125; &#125; &#125; return ary;&#125; 时间复杂度 最佳情况：输入数组按升序排列 T(n) = O(n)最坏情况：输入数组按降序排列 T(n) = O(n^2)平均情况：T(n) = O(n^2)","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"JS基础","slug":"JS基础","permalink":"/tags/JS基础/"},{"name":"排序算法","slug":"排序算法","permalink":"/tags/排序算法/"}]},{"title":"不同数据类型之间的比较","date":"2017-06-19T16:00:00.000Z","path":"js_compare_data_type/","text":"数据类型相互转换的规律 null 或 undefined 与任何其他数据类型比较结果都是 false null == undefined 为 true,但是 null === undefined为 false 对象 == 对象 为 false NaN与任何值进行比较结果都是false 布尔为假的值有： 0 、&quot;&quot; 、null、NaN、undefined, 其他为真 不同数据类型的比较最后都是将 &quot;==&quot; 两边转换成数字类型再比较 1. Number数据类型和其他数据类型的比较Number(), isNaN(), parseInt(), parseFloat() 数字 == 字符串 规则：字符串调用Number()强制转换为数字，然后进行比较 数字 == boolean 规则：将布尔值转换为0 或 1 ，再与数字想比较 数字 == null 结果是false 数字 == undefined 结果是false 数字 == 对象 规则： 先调用toString()把对象转化为字符串，再调用Number()强制转换为数字然后进行比较 总结： 数字数据类型和其他数据类型比较都是通过调用数据转换方法将其他数据类型转换成数字数据类型再与数字进行比较注意： 0 == []是true 因为Number([])结果为 0 ; 0 == {} false 因为Number({})结果为NaN 2. string数据类型与其他数据类型的比较toString() 字符串 == boolean 规律： 将==两边都调用Number()转化为数字再进行比较 字符串 == null 结果是false 字符串 == undefined 结果是false 字符串 == 对象 规律： 将==两边都转化为数字再进行比较 3. 布尔与其他数据类型的比较! 取反 ,!! 相当于boolean() 布尔 == null 结果是false 布尔 == undefined 结果是false 布尔 == 对象 规律： 两边都转换成数字数据类型再进行值的比较 4. null与其他数据类型的比较 null == undefined 结果是true null === undefined 结果是 false null == 对象 结果是 false null == null 结果是 true 5. undefined跟其他数据类型的比较 Undefined == 对象 结果是 false Undefined == undefined 结果是 true 6. 对象与对象对象 == 对象 结果是false 总结== 是需要经过以上规律进行数据类型的转换,然后进行数字或者字符串之间的比较,很多时候可能会出现问题.=== 更严格的比较,首先比较的是数据类型,再比较值,只有数据类型和值都相等的时候才相等,否则不等,引用数据类型之间永远不相等.","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"JS基础","slug":"JS基础","permalink":"/tags/JS基础/"},{"name":"比较","slug":"比较","permalink":"/tags/比较/"}]},{"title":"JavaScript中最最基础的知识点","date":"2017-06-17T16:00:00.000Z","path":"js_basics/","text":"JavaScript 中有很多很常用的也很基础的知识点需要我们牢牢记住,倒背如流,这样在开发的时候才能得心应手. 本文主要总结了DOM,Array,String,Math的一些常用方法,还有一些JS编程的基本常识. 1. DOM1.1 获取DOM元素12345678document.getElementByIddocument.getElementsByNamedocument.getElementsByTagNamedocument.getElementsByClassNamedocument.documentElementdocument.bodydocument.querySelectordocument.querySelectorAll 1.2 DOM节点 nodetype nodeName nodeValue 元素节点 1 大写的标签名 null 文本节点 3 #text 文本内容 注释节点 8 #comment 注释内容 document 9 #document null 1.3 DOM节点属性1234567parentNodechildNodeschildrenfirstChild (firstElementChild)lastChild (lastElementChild)previousSibling (previousElementSibling)nextSibling (nextElementSibling) 1.4 DOM操作123456789createElementappendChildinsertBeforereplaceChildremoveChildcloneNode(true/false)getAttributesetAttributeremoveAttribute 2. Array 数组常用方法1234567891011121314151617181920212223242526271.push2.pop3.shift4.unshift5.splice splice(n,m) 删除 返回值：删除的内容以新数组的形式返回 splice(n,0,x) 添加 splice(n,m,x) 替换6.slice查找 slice(n,m)克隆 slice()/ slice(0)7.concat数组拼接 ary1.concat(ary)克隆 ary1.concat();8.toString()9.join() eval()10.sort(function(a,b)&#123;return a-b&#125;)11.reverse()12.indexOf() 找到返回对应内容的索引 找不到-1；13.forEach()14.map();15.some();16.every();17.forEach();18.filter();19.reduce();20.includes(); 3. 字符串常用方法12345678910111213141.charAt2.charCodeAt3.indexOf()4.lastIndexOf();5.substr(n,m) 从索引n开始，找m个6.substring(n,m) 从索引n开始，找到索引m，不包含索引m7.slice(n,m)从索引n开始，找到索引m，不包含索引m; 可以取负值8.split() 字符串转数组9.toUpperCase() 转大写10.toLowerCase() 转小写11.replace('','') 替换12.search() 查找，找到返回索引，找不到-1；13.match() 匹配... 4. Math 常用方法123456789Math.random()Math.round() 四舍五入Math.floor() 向下取整Math.ceil() 向上取整Math.abs() 取绝对值Math.min() 取最小值Math.max() 取最大值Math.sqrt() 开平方Math.pow() 幂 5. 为何学习预解释 如果函数中未定义此变量，为何还能拿到 函数中定义的变量，但是在赋值之前，我们仍然能拿到值，但是拿到是undefined 为何把var去掉程序还能正常执行； 在定义函数之前，调用函数，也能执行函数，为什么？ 最终目的：写代码时，思路更加清楚，知道为何程序能正常执行，为何会报错？避免很多不正规的写法，因为这些不正规的写法很容出错，而且不会报错 6. 预解释概念：在当前作用域下，在JS代码执行之前，浏览器会对带var和带function进行提前声明或者定义； 声明：告诉浏览器有这么一个变量，但是没有赋值，没赋值拿到的undefined; 定义：对已经声明过的这个变量进行赋值 关于变量和函数预解释阶段的不同 带var :只声明不定义带function:声明+定义； 7. 函数定义步骤： 1.开辟一个空间地址2.把函数体中所有JS代码做为字符串存在这个空间中3.把空间地址赋值给函数名 函数调用步骤： 1.对形参赋值；2.预解释 var function;3.JS代码从上到下的执行 8. 作用域链当函数执行的时候，形成一个私有作用域A,查看作用域中的这个变量是否为私有变量： 1）如果是私有变量：这个函数中的所有此变量，跟外面没有任何关系；2）如果不是私有变量： 如果是获取；往上级作用域进行查找，如果找到，弹出，找不到继续往上级作用域进行查找…最终一直找到window，如果还没有，报错 如果是设置；往上级作用域进行查找，如果找到，重新赋值；找不到继续往上级作用域进行查找…最终一直找到window，如果还没有，他就是window上的全局属性； 9. 关于作用域全局作用域：当浏览器加载html页面的时候，会形成一个供JS代码执行的环境；在这个全局作用域下，所有的全局变量都是window上的全局属性； 所有的全局函数，都是window上的全局方法；私有作用域: 只在某个范围内有效,大多指函数内部 10. 带var和不带var的区别带var: 1）会进行预解释 2）如果是全局变量，window的全局属性 不带var: 1)不会进行预解释 2）如果是设置；往上级作用域进行查找，如果找到，重新赋值；找不到继续往上级作用域进行查找。。。。最终一直找到window，如果还没有，他就是window上的全局属性； 11. 私有变量有且只有两种 函数中带var的 形参 12. 关于预解释的无节操： 自执行函数不需要预解释，当代码执行到他的时候；声明+定义+调用同步完成； 已经声明过的变量，不需要重新声明，只需要重新赋值； 对于带var的，我们之对等号左边，进行声明；不运行等号右边的（即只声明，不定义） if 条件语句，无论条件是否成立，都会进行预解释注意：在 if条件语句中不要定义函数；因为各大浏览器对if语句的预解释不同；很容易出错； return返回值不进行预解释；return下面的语句虽然不执行，但是会进行预解释； 13. 闭包的作用 防止变量名冲突 在闭包中对全局变量重新赋值，并且不影响全局变量 可以通过window.xx改变全局变量； 闭包可以用来封装；可以通过window.xxx=函数名； 14. 函数当作表达式赋值给变量时注意事项：当函数做为表达式赋值给一个变量的时候，是按照变量的预解释机制进行预解释的； 这个变量名，是不是就相当于函数名，虽然不能在上面调用，但是可以在函数赋值后调用； 15. 内存js中内存：堆内存 和 栈内存 栈内存：提供了一个供JS代码执行的环境 环境：全局环境，私有环境 堆内存：存放是引用数据类型的值；对象：存的对象的属性名和属性值； 函数：把函数体中的JS代码做为字符串存在这个空间中 16. 内存释放堆内存释放：只要堆内存被变量占用，就无法释放； var a=xxff00; a=null; 解决措施：让 变量名=null； 即，让变量名等于空指针，当浏览器空闲的时候，就会把指向空指针的变量收回，浏览器的这种回收机制，叫做垃圾回收机制；栈内存：全局作用域：当浏览器加载完HTML页面的时候，就形成一个全局作用域；只有关闭页面，才能释放；如果不关闭页面，那么全局作用域下的所有变量和内容都无法得到释放；我们唯一能做的就是减少全局变量；私有作用域：当函数执行的时候，形成一个私有作用域；一般情况下，当函数执行完成的时候私有作用域就被释放；有两种情况不会被释放： 如果私有函数中有东西被函数外面的变量或者其他元素占用的时候，此函数不能释放； 不立即释放；这个函数执行完成的时候，会返回一个函数，被返回的这个函数还需要再执行一次，等返回的函数执行完成，所有的函数才能释放； 17. ++n 和 n++ 的区别++n 先++；再运算; 15+（++n）=16; 15+（++n）=17;n++ 先运算，再++; 15+n++=15; 15+n++=16;注意：再++时，只是 n 自身的++；跟整个运算没有关系； 18. 关于this的小总结 当触发一个元素身上的事件，执行对应的函数的时候，函数中的this，指向当前这个元素； 当函数执行的时候，”.”前面是谁，this就是谁 自执行函数中的this，永远都是window；","tags":[{"name":"JS","slug":"JS","permalink":"/tags/JS/"},{"name":"JS基础","slug":"JS基础","permalink":"/tags/JS基础/"}]},{"title":"NexT 主题配置","date":"2017-06-10T16:00:00.000Z","path":"theme_next/","text":"NexT 拥有丰富而简单的配置，结合第三方服务，打造属于您自己的博客.NexT 坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性。除了 Markdown 支持的语法之外，NexT 借助 Hexo 提供的标签特性， 为您提供在书写文档时快速插入带特殊样式的内容。使用 第三方服务 来扩展站点的功能， NexT 支持多种常见第三方服务。 1.统计文章阅读次数1.1 到 leancloud.cn 注册账号，创建应用， 1.2 在数据模块中 创建Class，名称一般为 Counter 1.3 在设置中拿到该应用的 App ID 、 App Key 1.4 设置安全域名，只有在允许的域名下才会进行正常的统计 1.5 在主题的_config.yml中进行配置1234leancloud_visitors:trueenable: truetrueapp_id: TrNg*****************Hsz #&lt;app_id&gt;trueapp_key: xPUp****************wAk #&lt;app_key&gt; 1.6 重新部署，然后访问，然后去 leancloud.cn 查看记录123hexo cleanhexo ghexo s 然后在文章中就可以看到阅读次数了 2.集成评论 gitmentnext主题在v5.1.2以上版本已经将gitment集成进去了，开启gitment只需要做以下操作 2.1 注册OAuth Application点击https://github.com/settings/applications/new注册，注意Authorization callback URL填自己的网站url http://songqibin.cn/.记下Client ID和Client Secret. 2.2 修改themes/next/_config.yml12345678910111213gitment: enable: true mint: true count: true lazy: false cleanly: true language: github_user: undo03 # MUST HAVE, Your Github ID github_repo: undo03.github.io # MUST HAVE, The repo you use to store Gitment comments client_id: 3ea3**************1507b # MUST HAVE, Github client id for the Gitment client_secret: 3bcd9a2e****************************d8d5 # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 这样基本就ok了，再根据自己的喜好调整样式。 注意:1.修改themes/next/_config.yml这个文件时，格式要正确。另外，github_repo是你要想创建issues的仓库，完全可以跟博文所放的仓库不一个。github_user就写自己的github用户名就可以，这个用户名跟repo必须匹配。2.同一篇文章需要初始化comment两次的问题，是因为http://xxx.com/post/ab9bb85a.html 和点击阅读全文进去的链接 http://xxx.com/post/ab9bb85a.html#more 对issues来说是不同的，所以创建两次。解决方法就是gitment.swig里id使用window.location.pathname而不是document.location.href。3.gitment在请求服务器的时候id字段有长度限制，超多长度限制请求会报错，当id是window.location.pathname的时候一般来说都会超长，解决方案是在 md 文件的 front-matter 中增加 subtitle: xxx，在hexo/_config.yml中设置 permalink: :year/:month/:day/:subtitle/ 即可4.初始化评论后，可以到github里自己放issues的仓库查看issues是否创建成功，有时候浏览器可能会有缓存依然提示你初始化评论。一般过个两分钟就显示正常了。 如需取消某个 页面/文章 的评论，在 md 文件的 front-matter 中增加 comments: false 3.添加版权信息主题配置文件下,搜索关键字post_copyright,enable改为true 12345# Declare license on postspost_copyright: enable: true license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 4. 开启百度分享主题配置文件下,搜索关键字baidushare,设置以下属性 123baidushare: type: button baidushare: true 5. 搜索添加百度/谷歌/本地 自定义站点内容搜索 5.1 安装 hexo-generator-search，在站点的根目录下执行以下命令：1$ npm install hexo-generator-search --save 5.2 编辑 站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 5.3 编辑 主题配置文件，启用本地搜索功能：12local_search: enable: true 以上搜索服务就配置完成了，再根据主题风格对样式进行修改 6. 未必力评论服务未必力评论的好处 使用社交网站账户登录,免去注册过程.提高用户的参与和沟通意愿管理/删除我的评论内容提供管理页面,管理网站文章及评论内容 添加步骤 在来必力的官网上注册账号。 在此处获取data-uid。 打开NexT主题的配置文_config中,搜索livere_uid,修改为 livere_uid: data-uid 如果大家仔细观察应该能发现这是韩国人的东西,但也正是因为这是外国人的东西,收到国内的各种条条框框的限制比较少.对于来必力,这个产品比较不错,首先界面美化上就比之前的几种类型要好很多,但是没有匿名评论,支持邮箱账号注册评论.","tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"主题配置","slug":"主题配置","permalink":"/tags/主题配置/"}]},{"title":"Hexo + github 搭建个人博客","date":"2017-06-09T16:00:00.000Z","path":"theme_init_blog/","text":"Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 Quick Start必备环境Git, NodeJs Hexo安装全局安装hexo 1$ npm install hexo-cli -g 到项目目录下初始化hexo项目123$ hexo init hexo_test &lt;project name&gt;$ cd hexo_test &amp;&amp; npm install 预览项目1234# 生成静态页面$ hexo generate # 启动本地服务，浏览器访问：http://localhost:4000$ hexo server 修改项目重新预览12345# 清空之前生成的静态页面$ hexo clean$ hexo generate$ hexo server 关联到GitHub在github上创建项目仓库,仓库名为yourgithubname/github.io12345# 配置Hexo的_config.ymldeploy: type: git repo: https://github.com/yourgithubname/yourgithubname.github.io.git branch: master 注意: 这里的repo 是你的git仓库对应的ssh地址,需要先配一下ssh 12345678# 要提交到Github上需要安装hexo-deployer-git插件 $ npm install hexo-deployer-git --save# 部署网站到Github上$ hexo deploy# 访问博客地址：http://undo03.github.io/# 大功告成!! 添加文章等信息,在source/_posts下创建并编辑markdown文件即可,支持文件夹分类,添加完成后按顺序执行以下命令即可部署到http://undo03.github.io/ 12345$ hexo clean$ hexo generate$ hexo deploy 更换主题hexo主题 去网站上选一款中意的主题12# 从Github下载主题$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho 在根目下的_config.yml文件中引入主题1theme: miho 然后重新生成静态文件先本地预览, 然后在主题文件夹下的_config.yml配置基本信息和订制化模块, 一般主题作者会有详细的教程文档和demo, 对应着替换成自己的信息即可 主题定制完成后, 按上面的部署顺序部署即可","tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"},{"name":"搭建博客","slug":"搭建博客","permalink":"/tags/搭建博客/"}]}]